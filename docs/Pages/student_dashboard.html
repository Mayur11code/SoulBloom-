<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoulBloom</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/lucide@latest"></script>

    <!-- Leaflet.js for Maps -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0F2923" />
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/48BB78/FFFFFF?text=G">
    <!-- 
      The Google Sign-In script is loaded asynchronously. 
      The 'onGoogleScriptsLoad' function will be our single entry point
      to start the rest of the Google API initialization process.
    -->
    <script>
        // Set a global flag when the GSI script's onload callback fires.
        // This helps prevent a race condition with DOMContentLoaded.
        window.googleGsiIsReady = false;
        function onGoogleScriptsLoad() {
            window.googleGsiIsReady = true;
            // Dispatch a custom event to let our main script know the GSI client is ready.
            window.dispatchEvent(new Event('google-gsi-loaded'));
        }
    </script>
    <script src="https://accounts.google.com/gsi/client" onload="onGoogleScriptsLoad()" async defer></script>
    <style>
        body {
            font-family: 'VT323', monospace;
            background-color: #0F2923;
            /* Deep Green */
            color: #E0E0E0;
            position: relative;
            overflow-x: hidden;
            /* Prevent horizontal scrollbar */
        }

        .widget {
            background-color: rgba(57, 65, 74, 0.5);
            /* Semi-transparent background */
            backdrop-filter: blur(10px);
            /* Frosted glass effect */
            -webkit-backdrop-filter: blur(10px);
            /* Safari support */
            border-radius: 8px;
            padding: 1.25rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            /* Subtle border */
        }

        .pixelated-bg {
            /* The background image will be set by JavaScript */
            background-color: #5B6F55;
            /* Added a fallback color */
            background-size: cover;
            background-position: center;
            height: 200px;
            image-rendering: pixelated;
        }

        .music-progress::-webkit-progress-bar {
            background-color: #4A5568;
            border-radius: 5px;
        }

        .music-progress::-webkit-progress-value {
            background-color: #68D391;
            border-radius: 5px;
        }

        .music-progress::-moz-progress-bar {
            background-color: #68D391;
            border-radius: 5px;
        }

        .task-checkbox {
            appearance: none;
            width: 1.25rem;
            height: 1.25rem;
            border: 2px solid #A0AEC0;
            border-radius: 4px;
            display: inline-block;
            position: relative;
            cursor: pointer;
            transition: all 0.2s;
        }

        .task-checkbox:checked {
            background-color: #68D391;
            border-color: #68D391;
        }

        .task-checkbox:checked::after {
            content: '✔';
            font-size: 1rem;
            color: #2E3338;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .task-item.completed span {
            text-decoration: line-through;
            color: #A0AEC0;
        }

        .course-tag {
            background-color: #ECC94B;
            color: #2E3338;
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 12px;
        }

        /* Floating elements styles */
        .floating-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
        }

        .floaty {
            position: absolute;
            background: rgba(104, 211, 145, 0.15);
            border-radius: 50%;
            animation: floatUp 25s infinite ease-in-out;
            opacity: 0;
            bottom: -100px;
            /* Start from below the screen */
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(1);
                opacity: 0;
            }

            10%,
            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-120vh) scale(1.5);
                opacity: 0;
            }
        }

        .gemini-response {
            white-space: pre-wrap;
            background: #2E3338;
            padding: 1rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            min-height: 50px;
        }

        /* Override notification list font */
        #notification-list {
            font-family: 'Roboto', sans-serif;
            font-size: 0.9rem;
            /* adjust size */
            line-height: 1.4;
            /* improve readability */
        }

        #notification-list strong {
            font-weight: 600;
            /* make titles bolder */
        }


        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #68D391;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Chat styles */
        .chat-message {
            display: flex;
            margin-bottom: 1rem;
            align-items: flex-end;
            gap: 0.5rem;
        }

        .chat-message.user {
            justify-content: flex-end;
        }

        .chat-bubble {
            padding: 0.75rem;
            border-radius: 0.5rem;
            max-width: 80%;
            line-height: 1.5;
        }

        .chat-bubble.other-user,
        .chat-bubble.ai {
            background-color: #2E3338;
        }

        .chat-bubble.user {
            background-color: #48BB78;
            color: #1A202C;
        }

        .chat-sender-id {
            font-size: 0.75rem;
            color: #A0AEC0;
            margin-bottom: 0.25rem;
        }

        /* Health Gauge Styles */
        .health-gauge {
            position: relative;
            width: 120px;
            height: 60px;
            /* Half of width */
            margin: 0 auto;
        }

        .gauge-arc {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .gauge-arc-segments {
            width: 120px;
            height: 60px;
            position: relative;
            overflow: hidden;
        }

        .gauge-arc-segments::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200%;
            /* Double height for full circle */
            border-radius: 50%;
            background: conic-gradient(from -90deg,
                    #F87171 0deg 36deg,
                    /* Red */
                    #FBBF24 36deg 72deg,
                    /* Amber */
                    #FCD34D 72deg 108deg,
                    /* Yellow */
                    #A3E635 108deg 144deg,
                    /* Lime */
                    #4ADE80 144deg 180deg
                    /* Green */
                );
        }

        .gauge-arc-mask {
            position: absolute;
            top: 10px;
            /* Arc thickness */
            left: 10px;
            /* Arc thickness */
            width: 100px;
            /* Width - 2 * thickness */
            height: 100px;
            background: #39414A;
            /* Same as widget background */
            border-radius: 50%;
        }

        .gauge-needle-container {
            position: absolute;
            bottom: -5px;
            left: 50%;
            width: 2px;
            height: 50px;
            transform-origin: bottom center;
            animation: sweep-needle 1.2s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
            transform: rotate(var(--needle-angle, -90deg));
        }

        @keyframes sweep-needle {
            from {
                transform: rotate(-90deg);
            }

            to {
                transform: rotate(var(--needle-angle));
            }
        }

        .gauge-needle {
            width: 100%;
            height: 100%;
            background-color: #F87171;
            border-radius: 2px;
        }

        .gauge-text {
            margin-top: 0.5rem;
            text-align: center;
        }

        .gauge-value {
            font-size: 1.5rem;
            display: block;
        }

        .gauge-label {
            font-size: 0.9rem;
            color: #A0AEC0;
        }

        .journal-entry-item {
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .gradient-button-container {
            padding: 2px;
            border-radius: 12px;
            background: conic-gradient(from 180deg at 50% 50%, #FBBF24, #A3E635, #4ADE80, #F87171, #FBBF24);
        }

        /* START OF ADDED SCREENING STYLES */
        .screening-progress-bar {
            transition: width 0.3s ease-in-out;
        }

        .screening-option-label {
            transition: all 0.2s ease-in-out;
            cursor: pointer;
        }

        .screening-option-label:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        input[type="radio"]:checked+.screening-option-label {
            background-color: #8e2de2;
            border-color: #a855f7;
            color: white;
        }

        /* END OF ADDED SCREENING STYLES */

        #emoji-panel.hidden {
            pointer-events: none;
        }

        #emoji-panel {
            pointer-events: auto;
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        .coping-kit-button {
            background-image: linear-gradient(to right, #8e2de2, #4a00e0);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px 0 rgba(142, 45, 226, 0.55);
        }

        .coping-kit-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 6px 20px 0 rgba(142, 45, 226, 0.7);
        }

        .coping-kit-dropdown {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.5s ease-in-out;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 0.5rem;
        }

        .coping-kit-dropdown.show {
            max-height: 500px;
            /* Adjust as needed */
            margin-top: 0.5rem;
        }

        #toggle-kit-dropdown-btn .lucide-chevron-down {
            transition: transform 0.3s ease-in-out;
        }

        #toggle-kit-dropdown-btn.open .lucide-chevron-down {
            transform: rotate(180deg);
        }


        /* newww */

        .glass {
            background: rgba(15, 41, 35, 0.6);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .font-vt323 {
            font-family: 'VT323', monospace;
        }

        .widget {
            background-color: transparent;
            border: none;
        }

        .pixelated-bg {
            background-color: #5B6F55;
            background-size: cover;
            background-position: center;
            height: 200px;
            image-rendering: pixelated;
        }

        .server-btn {
            background-color: transparent;
            transition: all 0.2s ease-in-out;
            position: relative;
        }

        .server-btn::before {
            content: '';
            position: absolute;
            left: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 0;
            background-color: #E0E0E0;
            border-radius: 0 4px 4px 0;
            transition: height 0.2s ease-in-out;
        }

        .server-btn:hover::before {
            height: 20px;
        }

        .server-btn.active::before {
            height: 40px;
        }

        .server-btn.active {
            border-radius: 1rem;
            background-color: #48BB78;
        }

        #channel-list-panel {
            width: 320px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            border-radius: 1rem;
            margin: 1rem 0 1rem 1rem;
            height: calc(100vh - 2rem);
            overflow: hidden;
            transition: width 0.3s ease-in-out, margin-left 0.3s ease-in-out;
        }

        #channel-list-panel.hidden {
            width: 0;
            margin-left: 0;
        }

        .channel-btn {
            color: #949ba4;
            transition: background-color 0.2s, color 0.2s;
            border-radius: 8px;
        }

        .channel-btn:hover {
            background-color: rgba(255, 255, 255, 0.05);
            color: #ffffff;
        }

        .channel-btn.active {
            background-color: #48BB78;
            color: #ffffff;
            font-weight: 500;
        }

        #user-panel {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.2);
        }

        #chat-area {
            border-radius: 1rem;
            margin: 1rem;
            height: calc(100vh - 2rem);
            overflow: hidden;
        }

        .chat-message {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            padding: 0.75rem 1.5rem;
            position: relative;
            animation: fade-in 0.3s ease-out;
        }

        @keyframes fade-in {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .chat-message.is-consecutive {
            padding-top: 0.1rem;
            padding-bottom: 0.1rem;
            margin-left: 4.0rem;
        }

        .chat-avatar {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.25rem;
            flex-shrink: 0;
            margin-top: 0.25rem;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .chat-sender-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.1rem;
        }

        .chat-text {
            line-height: 1.5;
            word-break: break-word;
            color: #dcdee1;
            font-size: 0.95rem;
        }

        #main-chat-input-wrapper {
            padding: 1rem 1.5rem;
        }

        #main-chat-input-container {
            background-color: transparent;
            border-radius: 0.75rem;
            padding: 0.25rem 0.5rem 0.25rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        #main-chat-input {
            background-color: transparent;
            border: none;
            outline: none;
            color: #E0E0E0;
            width: 100%;
        }

        #main-chat-send-btn {
            background-color: #48BB78;
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem;
            transition: background-color 0.2s;
        }

        #main-chat-send-btn:hover {
            background-color: #3da168;
        }

        #user-profile-popup {
            position: fixed;
            z-index: 50;
            width: 300px;
            border-radius: 8px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.24);
            transition: opacity 0.15s ease-out, transform 0.15s ease-out;
            opacity: 0;
            transform: scale(0.95) translateY(-10px);
            pointer-events: none;
        }

        #user-profile-popup.show {
            opacity: 1;
            transform: scale(1) translateY(0);
            pointer-events: auto;
        }

        #context-menu {
            position: fixed;
            z-index: 100;
            width: 220px;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            padding: 0.5rem;
            opacity: 0;
            transform: scale(0.95);
            transition: opacity 0.1s ease-out, transform 0.1s ease-out;
            pointer-events: none;
        }

        #context-menu.show {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }

        .context-menu-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border-radius: 4px;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.15s;
        }

        .context-menu-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .context-menu-item.danger:hover {
            background-color: #ef4444;
            color: white;
        }

        .context-menu-separator {
            height: 1px;
            background-color: rgba(255, 255, 255, 0.1);
            margin: 0.5rem 0;
        }

        #members-panel {
            width: 240px;
            background-color: rgba(15, 41, 35, 0.3);
            flex-shrink: 0;
            transition: width 0.3s ease-in-out, padding 0.3s ease-in-out;
            overflow: hidden;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
        }

        #members-panel.hidden {
            width: 0;
            padding: 0;
        }

        .chat-avatar.is-placeholder {
            visibility: hidden;
        }

        .chat-sender-name {
            font-weight: 500;
            cursor: pointer;
        }

        .chat-sender-name:hover {
            text-decoration: underline;
        }

        .chat-sender-name.user {
            color: #48BB78;
        }

        .chat-timestamp {
            font-size: 0.7rem;
            color: #949ba4;
        }

        .role-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .message-actions {
            position: absolute;
            top: 0;
            right: 1rem;
            background: rgba(15, 41, 35, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0.25rem;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        .message-actions:hover {
            opacity: 1;
        }

        .chat-message:hover .message-actions {
            opacity: 1;
        }

        .floating-elements {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            pointer-events: none;
            overflow: hidden;
        }

        .floaty {
            position: absolute;
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-bottom: 20px solid rgba(72, 187, 120, 0.15);
            animation: floatUp 25s infinite ease-in-out;
            opacity: 0;
            bottom: -150px;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) rotate(0deg) scale(1);
                opacity: 0;
            }

            10% {
                opacity: 1;
            }

            90% {
                opacity: 1;
            }

            100% {
                transform: translateY(-120vh) rotate(720deg) scale(1.5);
                opacity: 0;
            }
        }

        #attachment-menu {
            position: absolute;
            bottom: 100%;
            left: 0;
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transform-origin: bottom left;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
        }

        #attachment-btn {
            transition: transform 0.2s ease-out;
        }

        #image-preview-modal img {
            max-height: 60vh;
        }

        .chat-image {
            max-width: 320px;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            cursor: pointer;
        }

        .document-bubble {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background-color: rgba(255, 255, 255, 0.05);
            margin-top: 0.5rem;
        }

        #voice-recorder {
            animation: slide-up 0.3s ease-out;
        }

        @keyframes slide-up {
            from {
                opacity: 0;
                transform: translateY(100%);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        #emoji-panel {
            position: absolute;
            bottom: 100%;
            right: 0;
            margin-bottom: 0.5rem;
            width: 320px;
            height: 350px;
            border-radius: 0.5rem;
            transform-origin: bottom right;
            transition: transform 0.2s ease-out, opacity 0.2s ease-out;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .emoji-tab {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #949ba4;
            border-bottom: 2px solid transparent;
        }

        .emoji-tab.active {
            color: #ffffff;
            border-bottom-color: #48BB78;
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(32px, 1fr));
            gap: 0.5rem;
            padding: 0.5rem;
            overflow-y: auto;
        }

        .emoji-btn,
        .sticker-btn {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            border-radius: 4px;
            transition: background-color 0.15s;
        }

        .emoji-btn:hover,
        .sticker-btn:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sticker-btn {
            font-size: 3rem;
        }

        /* Hide sidebars on mobile by default */
        @media (max-width: 767px) {

            #server-nav,
            #channel-list-panel {
                transform: translateX(-100%);
                transition: transform 0.3s ease-in-out;
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 40;
            }

            /* When visible */
            #server-nav.active,
            #channel-list-panel.active {
                transform: translateX(0);
            }
        }


        /* Channel list hidden by default on mobile */
        @media (max-width: 767px) {
            #channel-list-panel {
                transform: translateX(-100%);
                transition: transform 0.3s ease-in-out;
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                width: 260px;
                z-index: 40;
                background-color: #2B2D31;
            }

            /* When open */
            #channel-list-panel.active {
                transform: translateX(0);
            }

            /* Optional dark overlay behind panel */
            #channel-overlay {
                display: none;
                position: fixed;
                inset: 0;
                background: rgba(0, 0, 0, 0.4);
                z-index: 30;
            }

            #channel-overlay.active {
                display: block;
            }
        }
    </style>

</head>

<body class="p-4 md:p-8">


    <!-- Hamburger toggle for small screens -->
    <button id="sidebar-toggle"
        class="md:hidden fixed top-4 left-4 z-50 bg-[#5865F2] text-white p-2 rounded-lg shadow-lg focus:outline-none">
        ☰
    </button>

    <div id="sidebar-overlay" class="hidden fixed inset-0 bg-black bg-opacity-40 z-30"></div>
    <!-- Channel list toggle (mobile only) -->
    
    





    <div class="floating-elements">
        <div class="floaty" style="left: 5%; animation-duration: 20s; animation-delay: 0s;"></div>
        <div class="floaty"
            style="left: 15%; animation-duration: 30s; animation-delay: 5s; border-bottom-width: 30px; border-left-width: 15px; border-right-width: 15px;">
        </div>
        <div class="floaty"
            style="left: 25%; animation-duration: 18s; animation-delay: 2s; border-bottom-width: 15px; border-left-width: 7px; border-right-width: 7px;">
        </div>
        <div class="floaty" style="left: 40%; animation-duration: 28s; animation-delay: 8s;"></div>
        <div class="floaty"
            style="left: 55%; animation-duration: 22s; animation-delay: 12s; border-bottom-width: 25px; border-left-width: 12px; border-right-width: 12px;">
        </div>
        <div class="floaty" style="left: 70%; animation-duration: 35s; animation-delay: 1s;"></div>
        <div class="floaty"
            style="left: 85%; animation-duration: 24s; animation-delay: 6s; border-bottom-width: 18px; border-left-width: 9px; border-right-width: 9px;">
        </div>
        <div class="floaty" style="left: 95%; animation-duration: 26s; animation-delay: 10s;"></div>
    </div>

    <div class="flex h-full">
        <div id="server-nav" class="w-14 md:w-20 p-2 md:p-3 flex flex-col items-center gap-3 flex-shrink-0">
            <button class="server-btn w-14 h-14 rounded-full flex items-center justify-center text-2xl active"
                data-view="dashboard" title="Dashboard">
                <i data-lucide="layout-dashboard" class="w-8 h-8"></i>
            </button>
            <button class="server-btn w-14 h-14 rounded-full flex items-center justify-center text-2xl" data-view="chat"
                title="Institute Server">
                <i data-lucide="sprout" class="w-8 h-8"></i>
            </button>
        </div>

        <div id="main-content" class="flex-1 flex flex-col min-w-0 relative">
            <div id="dashboard-view" class="w-full h-full overflow-y-auto">
                <!-- Custom Notification Banner -->
                <div id="notification-banner"
                    class="hidden fixed top-5 right-5 bg-green-500 text-white p-3 rounded-lg shadow-lg z-50 text-base">
                    <span id="notification-message"></span>
                    <button id="notification-close-btn" class="ml-4 font-bold">X</button>
                </div>

                <!-- Floating Elements Background -->
                <div class="floating-elements">
                    <div class="floaty"
                        style="width: 10px; height: 10px; left: 5%; animation-duration: 20s; animation-delay: 0s;">
                    </div>
                    <div class="floaty"
                        style="width: 20px; height: 20px; left: 15%; animation-duration: 30s; animation-delay: 5s;">
                    </div>
                    <div class="floaty"
                        style="width: 12px; height: 12px; left: 25%; animation-duration: 18s; animation-delay: 2s;">
                    </div>
                    <div class="floaty"
                        style="width: 15px; height: 15px; left: 40%; animation-duration: 28s; animation-delay: 8s;">
                    </div>
                    <div class="floaty"
                        style="width: 18px; height: 18px; left: 55%; animation-duration: 22s; animation-delay: 12s;">
                    </div>
                    <div class="floaty"
                        style="width: 8px; height: 8px; left: 70%; animation-duration: 35s; animation-delay: 1s;">
                    </div>
                    <div class="floaty"
                        style="width: 16px; height: 16px; left: 85%; animation-duration: 24s; animation-delay: 6s;">
                    </div>
                    <div class="floaty"
                        style="width: 13px; height: 13px; left: 95%; animation-duration: 26s; animation-delay: 10s;">
                    </div>
                </div>


                <div class="max-w-7xl mx-auto relative z-10">
                    <button id="notification-bell-btn"
                        class="fixed top-8 right-24 bg-gray-700 text-white p-3 rounded-full shadow-lg hover:bg-gray-600 transition-colors z-40">
                        <i data-lucide="bell" class="w-6 h-6"></i>
                        <span id="notification-badge"
                            class="hidden absolute -top-1 -right-1 flex justify-center items-center w-5 h-5 text-xs bg-red-500 rounded-full"></span>
                    </button>
                    <!-- SOS Button -->
                    <button id="sos-btn"
                        class="fixed top-8 right-8 bg-orange-400 text-white p-3 rounded-full shadow-lg hover:bg-orange-500 transition-transform hover:scale-110 z-40">
                        <i data-lucide="siren" class="w-6 h-6"></i>
                    </button>

                    <!-- Header Image -->
                    <div class="pixelated-bg rounded-lg relative">
                        <div class="absolute inset-0 bg-black/40 rounded-lg"></div> <!-- Brightness Overlay -->
                        <div class="absolute -bottom-8 left-8">
                            <button id="profile-pic-container"
                                class="bg-[#39414A]/50 backdrop-blur-[10px] p-3 rounded-lg border border-white/10 shadow-[0_0_20px_rgba(160,130,255,0.5)] transition-transform hover:scale-105">
                                <span id="profile-pic-emoji" class="text-5xl">☘️</span>
                            </button>
                        </div>
                        <div class="absolute bottom-4 left-32 text-2xl">
                            <span id="user-anonymous-name" class="font-bold"></span>
                            <span id="user-verification-badge" class="hidden" title="Mental Health Screening Completed">
                                <i data-lucide="shield-check" class="w-6 h-6 text-green-400"></i>
                            </span>
                        </div>
                    </div>

                    <!-- Main Dashboard Grid -->
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 pt-6 mt-6">

                        <!-- Sidebar -->
                        <div class="lg:col-span-3 grid grid-cols-1 lg:grid-cols-3 gap-6 min-w-0">
                            <div class="widget">
                                <button id="study-help-btn" class="gradient-button-container w-full">
                                    <div
                                        class="bg-black rounded-lg p-3 text-center hover:bg-gray-900 transition-colors flex items-center justify-center gap-2 text-lg">
                                        <i data-lucide="graduation-cap" class="w-5 h-5 text-yellow-400"></i>
                                        <span>Study Help !!</span>
                                    </div>
                                </button>
                            </div>
                            <!-- START OF EDIT: Added Screening Button -->
                            <div class="widget">
                                <button id="open-screening-btn" class="w-full">
                                    <div
                                        class="bg-gradient-to-r from-purple-500 to-indigo-600 text-white rounded-lg p-3 text-center hover:from-purple-600 hover:to-indigo-700 transition-all flex items-center justify-center gap-2 text-lg shadow-lg hover:shadow-xl">
                                        <i data-lucide="clipboard-check" class="w-5 h-5"></i>
                                        <span>Mental Health Screening</span>
                                    </div>
                                </button>
                            </div>
                            <!-- END OF EDIT -->
                            <!-- <div class="widget h-full">
                                <div class="flex justify-between items-center mb-4">
                                    <h2 class="text-xl">Chat Rooms</h2>
                                    <div class="flex items-center gap-2">
                                        <button class="text-gray-400 hover:text-white"><i data-lucide="search"
                                                class="w-5 h-5"></i></button>
                                    </div>
                                </div>
                                <div class="space-y-2">
                                    <button
                                        class="chatroom-btn w-full text-left p-2 rounded hover:bg-white/10 transition-colors flex items-center gap-2"
                                        data-room-name="General Chat">
                                        <i data-lucide="message-square" class="w-4 h-4"></i> General Chat
                                    </button>
                                    <button
                                        class="chatroom-btn w-full text-left p-2 rounded hover:bg-white/10 transition-colors flex items-center gap-2"
                                        data-room-name="Study Group">
                                        <i data-lucide="book-open" class="w-4 h-4"></i> Study Group
                                    </button>
                                    <button
                                        class="chatroom-btn w-full text-left p-2 rounded hover:bg-white/10 transition-colors flex items-center gap-2"
                                        data-room-name="Gaming Corner">
                                        <i data-lucide="gamepad-2" class="w-4 h-4"></i> Gaming Corner
                                    </button>
                                </div>
                            </div> -->
                        </div>

                        <!-- Main Content Area -->
                        <div class="lg:col-span-3 grid grid-cols-1 lg:grid-cols-3 gap-6 min-w-0">
                            <!-- Left Column -->
                            <div class="lg:col-span-1 flex flex-col gap-6">
                                <!-- Helpful Links -->
                                <div class="widget">
                                    <div class="flex justify-between items-center">
                                        <h2 class="text-xl mb-3 flex items-center gap-2"><i data-lucide="link-2"
                                                class="w-5 h-5"></i> Helpful Links</h2>
                                        <button id="helpful-link-btn"
                                            class="text-sm bg-green-500/80 text-white px-3 py-1 rounded hover:bg-green-600">✨
                                            Find a
                                            Link</button>
                                    </div>
                                    <ul id="helpful-links-list" class="space-y-2 mt-2">
                                        <li><a href="https://telemanas.mohfw.gov.in/" target="_blank"
                                                class="hover:text-green-400">✧
                                                Tele MANAS</a></li>
                                    </ul>
                                </div>

                                <!-- Journaling -->
                                <div class="widget">
                                    <div class="flex justify-between items-center mb-3">
                                        <h2 class="text-xl flex items-center gap-2"><i data-lucide="book-heart"
                                                class="w-5 h-5"></i>
                                            Journaling</h2>
                                        <div class="flex items-center gap-2 text-sm text-gray-400">
                                            <span>Local</span>
                                            <label class="relative inline-flex items-center cursor-pointer">
                                                <input type="checkbox" id="journal-storage-toggle" class="sr-only peer">
                                                <div
                                                    class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-purple-500">
                                                </div>
                                            </label>
                                            <span>Server</span>
                                            <button id="sync-journal-btn"
                                                class="ml-2 text-sm text-cyan-400 hover:text-cyan-300 hidden">Sync to
                                                Server</button>
                                        </div>
                                    </div>
                                    <button id="shadow-work-prompt-btn"
                                        class="w-full text-sm bg-purple-500/80 text-white px-3 py-2 rounded hover:bg-purple-600 mb-3">🔮
                                        New Shadow Work Prompt</button>
                                    <textarea id="journal-entry"
                                        class="w-full h-32 bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-purple-400 text-base"
                                        placeholder="What's on your mind?"></textarea>
                                    <button id="save-journal-entry-btn"
                                        class="w-full mt-2 text-sm bg-green-500/80 text-white px-3 py-2 rounded hover:bg-green-600">Save
                                        Entry</button>

                                    <div id="journal-history-container" class="mt-4">
                                        <h3 class="text-lg mb-2">Past Entries</h3>
                                        <div id="journal-history-list" class="space-y-2 max-h-40 overflow-y-auto pr-2">
                                            <!-- Journal history will be loaded here -->
                                        </div>
                                    </div>
                                </div>

                                <!-- User Health -->
                                <div class="widget">
                                    <h2 class="text-xl mb-4 flex items-center gap-2"><i data-lucide="heart-pulse"
                                            class="w-5 h-5"></i> User Health</h2>
                                    <div id="health-stats-container" class="flex flex-col gap-6 items-center"
                                        style="min-height: 150px;">
                                        <!-- Health gauges will be injected here by JS -->
                                    </div>
                                    <div id="google-fit-auth-container" class="mt-4 text-center">
                                        <!-- This will show a login button or a sync message -->
                                    </div>
                                </div>

                                <!-- Weather -->
                                <div class="widget">
                                    <h2 class="text-sm text-gray-400">DELHI WEATHER</h2>
                                    <div class="flex items-center justify-between mt-2">
                                        <p class="text-5xl">28°C</p>
                                        <div class="text-right">
                                            <i data-lucide="cloud-sun" class="w-12 h-12 ml-auto"></i>
                                            <p>broken clouds</p>
                                        </div>
                                    </div>
                                    <div class="mt-4 pt-4 border-t border-gray-600 flex justify-between text-center">
                                        <div class="flex flex-col items-center">
                                            <p>SAT</p>
                                            <i data-lucide="sun" class="w-6 h-6 my-1"></i>
                                            <p>38°C</p>
                                            <p class="text-gray-400">24°C</p>
                                        </div>
                                        <div class="flex flex-col items-center">
                                            <p>SUN</p>
                                            <i data-lucide="cloud-sun" class="w-6 h-6 my-1"></i>
                                            <p>35°C</p>
                                            <p class="text-gray-400">24°C</p>
                                        </div>
                                        <div class="flex flex-col items-center">
                                            <p>MON</p>
                                            <i data-lucide="cloud-drizzle" class="w-6 h-6 my-1"></i>
                                            <p>34°C</p>
                                            <p class="text-gray-400">21°C</p>
                                        </div>
                                        <div class="flex flex-col items-center">
                                            <p>TUE</p>
                                            <i data-lucide="cloud-lightning" class="w-6 h-6 my-1"></i>
                                            <p>31°C</p>
                                            <p class="text-gray-400">18°C</p>
                                        </div>
                                        <div class="flex flex-col items-center">
                                            <p>WED</p>
                                            <i data-lucide="cloud" class="w-6 h-6 my-1"></i>
                                            <p>29°C</p>
                                            <p class="text-gray-400">18°C</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <!-- Right Column -->
                            <div class="lg:col-span-2 flex flex-col gap-6">

                                <!-- Guided Meditation -->
                                <div class="widget">
                                    <div class="flex justify-between items-center mb-3">
                                        <h2 class="text-xl flex items-center gap-2"><i data-lucide="brain-circuit"
                                                class="w-5 h-5"></i> Guided Meditation</h2>
                                        <div class="flex items-center gap-2">
                                            <button id="clear-meditation-btn" title="Clear Meditation"
                                                class="text-gray-400 hover:text-white"><i data-lucide="trash-2"
                                                    class="w-4 h-4"></i></button>
                                            <button id="toggle-meditation-btn" title="Minimize"
                                                class="text-gray-400 hover:text-white"><i data-lucide="chevron-up"
                                                    class="w-5 h-5"></i></button>
                                        </div>
                                    </div>
                                    <div id="meditation-widget-body">
                                        <p class="text-gray-400 mb-3 text-base">Enter a topic and select a language for
                                            your guided
                                            meditation.</p>
                                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                            <input type="text" id="meditation-topic-input"
                                                placeholder="e.g., Releasing anxiety"
                                                class="bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400 text-base">
                                            <select id="meditation-language-select"
                                                class="bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400 text-base">
                                                <option value="English (India)">English (India)</option>
                                                <option value="Hindi">Hindi</option>
                                                <option value="Bengali">Bengali</option>
                                                <option value="Tamil">Tamil</option>
                                                <option value="Telugu">Telugu</option>
                                                <option value="Marathi">Marathi</option>
                                                <option value="other">Other...</option>
                                            </select>
                                        </div>
                                        <input type="text" id="meditation-language-search"
                                            placeholder="Enter language name (e.g., French)"
                                            class="hidden w-full bg-[#2E3338] p-2 mt-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400 text-base">
                                        <div class="flex gap-2 mt-2">
                                            <button id="generate-meditation-btn"
                                                class="w-full bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">Generate
                                                Script</button>
                                            <button id="play-meditation-btn"
                                                class="w-full bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600"
                                                disabled>Play Meditation</button>
                                        </div>
                                        <div id="meditation-script-container"
                                            class="gemini-response hidden mt-3 max-h-48 overflow-y-auto"></div>
                                        <audio id="meditation-audio-player" class="w-full mt-3 hidden"></audio>
                                    </div>
                                </div>

                                <!-- Serenity Map -->
                                <div class="widget">
                                    <h2 class="text-xl mb-3 flex items-center gap-2"><i data-lucide="map"
                                            class="w-5 h-5"></i>
                                        Serenity Map</h2>
                                    <div class="flex gap-2 mb-3">
                                        <input type="text" id="location-search-input"
                                            placeholder="Search any location in India..."
                                            class="w-full bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400 text-base">
                                        <button id="location-search-btn"
                                            class="bg-green-500 text-white px-4 py-2 rounded hover:bg-green-600">Search</button>
                                    </div>
                                    <div id="map" class="w-full h-64 bg-[#2E3338] rounded"></div>
                                </div>

                                <!-- Assignments -->
                                <div class="widget">
                                    <div class="flex justify-between items-center mb-3">
                                        <h2 class="text-xl flex items-center gap-2"><i data-lucide="clipboard-check"
                                                class="w-5 h-5"></i> assignments</h2>
                                        <div class="flex items-center gap-2 text-sm text-gray-400">
                                            <span>Local</span>
                                            <label class="relative inline-flex items-center cursor-pointer">
                                                <input type="checkbox" id="storage-toggle" class="sr-only peer">
                                                <div
                                                    class="w-11 h-6 bg-gray-600 rounded-full peer peer-checked:after:translate-x-full after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-500">
                                                </div>
                                            </label>
                                            <span>Server</span>
                                            <button id="sync-assignments-btn"
                                                class="ml-2 text-sm text-cyan-400 hover:text-cyan-300 hidden">Sync to
                                                Server</button>
                                        </div>
                                    </div>

                                    <div id="assignments-list" class="space-y-2">
                                        <div
                                            class="grid grid-cols-[auto,1fr,auto,auto,auto] gap-x-4 items-center text-sm text-gray-400 pb-1 border-b border-gray-600">
                                            <span></span>
                                            <span>Name</span>
                                            <span>Course</span>
                                            <span>Due Date</span>
                                            <span></span>
                                        </div>
                                        <!-- Dynamic tasks will be inserted here -->
                                    </div>
                                    <form id="new-assignment-form" class="mt-4 hidden">
                                        <div class="grid grid-cols-1 md:grid-cols-3 gap-2 text-base">
                                            <input type="text" id="new-assignment-name" placeholder="Task Name"
                                                class="bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400"
                                                required>
                                            <input type="text" id="new-assignment-course" placeholder="Course"
                                                class="bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400">
                                            <input type="date" id="new-assignment-due-date"
                                                class="bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400">
                                        </div>
                                        <div class="flex justify-end gap-2 mt-2">
                                            <button type="button" id="cancel-assignment-btn"
                                                class="text-sm text-gray-400 hover:text-white px-3 py-1 rounded">Cancel</button>
                                            <button type="submit"
                                                class="text-sm bg-green-500/80 text-white px-3 py-1 rounded hover:bg-green-600">Add
                                                Task</button>
                                        </div>
                                    </form>
                                    <button id="new-assignment-btn"
                                        class="mt-4 text-gray-400 hover:text-white flex items-center gap-2"><i
                                            data-lucide="plus" class="w-4 h-4"></i> New</button>
                                </div>

                                <!-- Music Player -->
                                <div class="widget">
                                    <div class="flex justify-between items-center mb-4">
                                        <div class="flex items-center gap-3">
                                            <i data-lucide="music-4" class="w-6 h-6 text-green-400"></i>
                                            <div>
                                                <h3 class="text-lg">chill vibes</h3>
                                                <p class="text-sm text-gray-400">lo-fi beats</p>
                                            </div>
                                        </div>
                                        <div class="flex gap-2">
                                            <button id="spotify-btn"
                                                class="text-sm bg-[#1DB954]/80 text-white px-3 py-1 rounded hover:bg-[#1DB954] transition-colors">Spotify</button>
                                            <button id="yt-music-btn"
                                                class="text-sm bg-[#FF0000]/80 text-white px-3 py-1 rounded hover:bg-[#FF0000] transition-colors">YT
                                                Music</button>
                                        </div>
                                    </div>
                                    <div id="music-player-container" class="w-full h-96 mt-2">
                                        <!-- Music player content is managed by JavaScript -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>



                <!-- blossom AI Chatbot Icon -->
                <button id="ai-chat-toggle-btn"
                    class="fixed bottom-8 right-8 bg-fuchsia-500 text-white p-4 rounded-full shadow-lg hover:bg-fuchsia-600 transition-transform hover:scale-110 z-30">
                    <i data-lucide="flower-2" class="w-8 h-8"></i>
                </button>

                <!-- blossom AI Chat Window -->
                <div id="ai-chat-window"
                    class="fixed bottom-24 right-8 w-full max-w-md bg-[#39414A] rounded-lg shadow-2xl border border-[#4A5568] hidden flex flex-col z-30"
                    style="height: 500px;">
                    <div class="flex justify-between items-center p-3 bg-[#2E3338] rounded-t-lg">
                        <h3 class="text-lg flex items-center gap-2"><i data-lucide="flower-2"
                                class="w-5 h-5 text-fuchsia-400"></i>
                            blossom AI</h3>
                        <div class="flex items-center gap-3">
                            <select id="ai-personality-selector"
                                class="bg-[#39414A] text-sm rounded p-1 border border-[#4A5568] focus:outline-none text-white">
                                <option value="helpful">Helpful</option>
                                <option value="creative">Creative</option>
                                <option value="sarcastic">Sarcastic</option>
                            </select>
                            <button id="ai-chat-clear-btn" title="Clear chat history"
                                class="text-gray-400 hover:text-white">
                                <i data-lucide="trash-2" class="w-4 h-4"></i>
                            </button>
                            <button id="ai-chat-close-btn" class="text-gray-400 hover:text-white">
                                <i data-lucide="x" class="w-5 h-5"></i>
                            </button>
                        </div>
                    </div>
                    <div id="ai-chat-messages" class="flex-1 p-4 overflow-y-auto space-y-4"></div>
                    <div class="p-3 border-t border-[#4A5568]">
                        <div class="flex gap-2">
                            <input type="text" id="ai-chat-input" placeholder="Ask me anything..."
                                class="w-full bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-fuchsia-400 text-base">
                            <button id="ai-chat-send-btn"
                                class="bg-fuchsia-500 text-white px-4 py-2 rounded hover:bg-fuchsia-600 flex items-center justify-center">
                                <i data-lucide="send" class="w-5 h-5"></i>
                            </button>
                        </div>
                    </div>
                </div>


                <!-- Emote Picker Modal -->
                <div id="emote-picker-modal"
                    class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center hidden z-50">
                    <div class="widget p-6 rounded-lg max-w-sm w-full">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl">Choose a new picture</h3>
                            <button id="close-emote-modal" class="text-gray-400 hover:text-white">
                                <i data-lucide="x" class="w-6 h-6"></i>
                            </button>
                        </div>
                        <div id="emote-grid" class="grid grid-cols-4 gap-4 text-4xl text-center">
                            <!-- Emotes will be populated by JS -->
                        </div>
                    </div>
                </div>

                <!-- SOS Sidebar -->
                <div id="sos-sidebar"
                    class="fixed top-0 right-0 w-80 h-full bg-[#39414A]/80 backdrop-blur-lg border-l border-white/10 shadow-2xl z-50 transform translate-x-full transition-transform duration-300 ease-in-out">
                    <div class="p-4">
                        <div class="flex justify-between items-center mb-6">
                            <h2 class="text-xl flex items-center gap-2"><i data-lucide="life-buoy" class="w-5 h-5"></i>
                                Emergency
                                Support</h2>
                            <button id="close-sos-sidebar" class="text-gray-400 hover:text-white"><i data-lucide="x"
                                    class="w-6 h-6"></i></button>
                        </div>
                        <div class="space-y-3 text-lg">
                            <a href="tel:14416"
                                class="flex items-center gap-3 p-3 rounded-lg hover:bg-white/10 transition-colors">
                                <i data-lucide="phone" class="w-5 h-5"></i>
                                <span>Tele MANAS: 14416</span>
                            </a>
                            <a href="tel:18005990019"
                                class="flex items-center gap-3 p-3 rounded-lg hover:bg-white/10 transition-colors">
                                <i data-lucide="shield-half" class="w-5 h-5"></i>
                                <span>Vandrevala Fdn: 1800-599-0019</span>
                            </a>
                            <button id="quick-meditation-sos-btn"
                                class="w-full text-left flex items-center gap-3 p-3 rounded-lg hover:bg-white/10 transition-colors">
                                <i data-lucide="sparkles" class="w-5 h-5"></i>
                                <span>Quick Meditation</span>
                            </button>
                            <button id="breathing-exercise-sos-btn"
                                class="w-full text-left flex items-center gap-3 p-3 rounded-lg hover:bg-white/10 transition-colors">
                                <i data-lucide="wind" class="w-5 h-5"></i>
                                <span>Breathing Exercise</span>
                            </button>
                        </div>
                        <div class="mt-8 pt-6 border-t border-white/20">
                            <div class="flex justify-between items-center">
                                <h3 class="text-lg font-semibold flex items-center gap-2">
                                    <i data-lucide="package-check" class="w-5 h-5"></i>
                                    Offline Coping Kit
                                </h3>
                                <div class="flex items-center rounded-full coping-kit-button text-white">
                                    <button id="download-all-kit-btn" title="Download All Resources as .zip"
                                        class="flex items-center gap-2 px-3 py-1 text-sm">
                                        <i data-lucide="download-cloud" class="w-4 h-4"></i>
                                        <span id="download-all-text">All</span>
                                    </button>
                                    <div class="border-l border-white/30 h-4"></div>
                                    <button id="toggle-kit-dropdown-btn" title="Show Individual Files"
                                        class="px-2 py-1">
                                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>

                            <div id="coping-kit-dropdown-menu" class="coping-kit-dropdown">
                                <div class="space-y-2 text-base p-3">
                                    <button data-kit-item="contacts"
                                        class="kit-item-btn w-full text-left flex items-center gap-3 p-2 rounded-lg hover:bg-white/10 transition-colors">
                                        <i data-lucide="contact" class="w-5 h-5 text-cyan-400"></i>
                                        <span>Emergency Contacts (.txt)</span>
                                    </button>
                                    <button data-kit-item="exercises"
                                        class="kit-item-btn w-full text-left flex items-center gap-3 p-2 rounded-lg hover:bg-white/10 transition-colors">
                                        <i data-lucide="feather" class="w-5 h-5 text-green-400"></i>
                                        <span>Calming Exercises (.txt)</span>
                                    </button>
                                    <button data-kit-item="affirmations"
                                        class="kit-item-btn w-full text-left flex items-center gap-3 p-2 rounded-lg hover:bg-white/10 transition-colors">
                                        <i data-lucide="sparkles" class="w-5 h-5 text-yellow-400"></i>
                                        <span>Positive Affirmations (.txt)</span>
                                    </button>
                                    <button data-kit-item="prompts"
                                        class="kit-item-btn w-full text-left flex items-center gap-3 p-2 rounded-lg hover:bg-white/10 transition-colors">
                                        <i data-lucide="book-open-text" class="w-5 h-5 text-orange-400"></i>
                                        <span>5-Min Journal Prompts (.txt)</span>
                                    </button>
                                    <button data-kit-item="hope-card"
                                        class="kit-item-btn w-full text-left flex items-center gap-3 p-2 rounded-lg hover:bg-white/10 transition-colors">
                                        <i data-lucide="image" class="w-5 h-5 text-purple-400"></i>
                                        <span>Digital Hope Card (.png)</span>
                                    </button>
                                    <button data-kit-item="mandala"
                                        class="kit-item-btn w-full text-left flex items-center gap-3 p-2 rounded-lg hover:bg-white/10 transition-colors">
                                        <i data-lucide="circle-dot" class="w-5 h-5 text-fuchsia-400"></i>
                                        <span>Mindfulness Mandala (.png)</span>
                                    </button>
                                </div>
                            </div>

                            <p class="text-xs text-gray-400 mt-4">Download a complete kit or select individual resources
                                to use them
                                anytime, even without an internet connection.</p>
                        </div>
                    </div>

                </div>

                <!-- START OF ADDED NOTIFICATION PANEL -->
                <div id="notification-panel"
                    class="hidden fixed top-24 right-8 w-80 bg-[#39414A]/90 backdrop-blur-lg border border-white/10 shadow-2xl z-50 rounded-lg">
                    <div class="p-4 border-b border-white/10 flex justify-between items-center">
                        <h3 class="text-lg">Notifications</h3>
                        <button id="clear-notifications-btn" class="text-sm text-gray-400 hover:text-white hidden">Clear
                            All</button>
                    </div>
                    <div id="notification-list" class="p-2 max-h-80 overflow-y-auto">
                        <!-- Notifications will be loaded here -->
                    </div>
                </div>
                <!-- END OF ADDED NOTIFICATION PANEL -->

                <!-- Journal Analysis Modal -->
                <div id="journal-analysis-modal"
                    class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center hidden z-50">
                    <div class="widget p-6 rounded-lg max-w-xl w-full">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl flex items-center gap-2"><i data-lucide="brain-circuit"
                                    class="w-5 h-5"></i> AI
                                Journal Analysis</h3>
                            <button id="close-journal-analysis-modal" class="text-gray-400 hover:text-white">
                                <i data-lucide="x" class="w-6 h-6"></i>
                            </button>
                        </div>
                        <div id="journal-analysis-content" class="gemini-response max-h-[60vh] overflow-y-auto">
                            <!-- AI analysis will be loaded here -->
                        </div>
                    </div>
                </div>

                <!-- Study Help Modal -->
                <div id="study-help-modal"
                    class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center hidden z-50">
                    <div class="widget p-6 rounded-lg max-w-lg w-full flex flex-col" style="height: 70vh;">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl flex items-center gap-2"><i data-lucide="graduation-cap"
                                    class="w-5 h-5 text-yellow-400"></i> Study Help !!</h3>
                            <button id="close-study-help-modal" class="text-gray-400 hover:text-white">
                                <i data-lucide="x" class="w-6 h-6"></i>
                            </button>
                        </div>
                        <div id="study-upload-view" class="space-y-3 text-base">
                            <p class="text-sm text-gray-400">Upload a document (PDF, TXT) to start a chat session.</p>
                            <label for="study-file-upload"
                                class="flex flex-col items-center justify-center w-full h-32 border-2 border-dashed rounded-lg cursor-pointer bg-[#2E3338] border-gray-600 hover:border-gray-500 hover:bg-[#39414A]">
                                <div class="flex flex-col items-center justify-center pt-5 pb-6">
                                    <i data-lucide="upload-cloud" class="w-10 h-10 mb-2 text-gray-400"></i>
                                    <p class="mb-1 text-sm text-gray-400"><span class="font-semibold">Click to
                                            upload</span></p>
                                    <p id="study-file-name" class="text-xs text-gray-400">PDF, TXT, MD, etc. (MAX. 5MB)
                                    </p>
                                </div>
                                <input id="study-file-upload" type="file" class="hidden"
                                    accept=".pdf, .txt, .md, .csv, text/plain, application/pdf" />
                            </label>
                        </div>
                        <div id="study-chat-view" class="hidden flex-1 flex flex-col min-h-0">
                            <div class="flex justify-between items-center p-2 bg-black/20 rounded mb-2">
                                <p id="study-chat-file-name" class="text-sm truncate text-gray-300"></p>
                                <button id="study-end-chat-btn" class="text-xs text-red-400 hover:text-white">End
                                    Session</button>
                            </div>
                            <div id="study-chat-messages"
                                class="flex-1 p-4 overflow-y-auto space-y-4 bg-black/10 rounded">
                                <!-- Study chat messages will appear here -->
                            </div>
                            <div class="p-3 border-t border-[#4A5568] mt-2">
                                <div class="flex gap-2">
                                    <input type="text" id="study-chat-input"
                                        placeholder="Ask a question about the document..."
                                        class="w-full bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-yellow-400 text-base">
                                    <button id="study-chat-send-btn"
                                        class="bg-yellow-500 text-white px-4 py-2 rounded hover:bg-yellow-600 flex items-center justify-center">
                                        <i data-lucide="send" class="w-5 h-5"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="screening-modal"
                    class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center hidden z-50">
                    <div class="widget p-6 rounded-lg max-w-2xl w-full flex flex-col" style="height: 80vh;">
                        <div class="flex justify-between items-center mb-4">
                            <h3 class="text-xl flex items-center gap-2"><i data-lucide="file-text" class="w-5 h-5"></i>
                                Mental
                                Health Screening</h3>
                            <button id="close-screening-modal" class="text-gray-400 hover:text-white"><i data-lucide="x"
                                    class="w-6 h-6"></i></button>
                        </div>

                        <div id="screening-intro-view">
                            <h4 class="text-lg font-semibold mb-2">About this Screening</h4>
                            <p class="text-gray-300 text-base mb-4">This is a confidential screening tool based on the
                                Patient
                                Health Questionnaire (PHQ-9) and the Generalized Anxiety Disorder (GAD-7) assessment. It
                                is intended
                                to help you understand your emotional well-being and is not a substitute for a
                                professional
                                diagnosis.</p>
                            <p class="text-gray-400 text-sm mb-6">Your aggregated, anonymous data may be used to help us
                                understand
                                the well-being of our user community. Your individual responses will not be shared.</p>
                            <button id="start-screening-btn"
                                class="w-full bg-indigo-600 text-white py-3 rounded-lg text-lg hover:bg-indigo-700 transition-colors">Start
                                Screening</button>
                        </div>

                        <div id="screening-questions-view" class="hidden flex-1 flex flex-col min-h-0">
                            <div class="w-full bg-gray-700 rounded-full h-2.5 mb-4">
                                <div id="screening-progress-bar"
                                    class="bg-gradient-to-r from-purple-500 to-indigo-500 h-2.5 rounded-full screening-progress-bar"
                                    style="width: 0%"></div>
                            </div>
                            <div id="screening-question-container" class="flex-1 overflow-y-auto pr-2">
                                <p class="text-lg text-gray-300 mb-2">Over the last <strong>2 weeks</strong>, how often
                                    have you
                                    been bothered by the following problems?</p>
                                <h3 id="screening-question-text" class="text-2xl font-semibold mb-4"></h3>
                                <div id="screening-options" class="space-y-2 text-lg"></div>
                            </div>
                            <div class="mt-4 flex justify-between items-center">
                                <button id="screening-back-btn"
                                    class="text-gray-400 hover:text-white disabled:opacity-50 disabled:cursor-not-allowed">
                                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                                </button>
                                <span id="screening-question-counter" class="text-sm text-gray-400"></span>
                                <button id="screening-next-btn"
                                    class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700 transition-colors disabled:bg-gray-600 disabled:cursor-not-allowed">
                                    Next
                                </button>
                            </div>
                        </div>

                        <div id="screening-results-view"
                            class="hidden flex-1 flex-col min-h-0 items-center justify-center text-center">
                            <i data-lucide="check-circle-2" class="w-16 h-16 text-green-400 mb-4"></i>
                            <h3 class="text-2xl font-bold mb-2">Screening Complete</h3>
                            <p class="text-gray-300 mb-4">Thank you for completing the screening. Your results are being
                                processed.
                            </p>
                            <p class="text-sm text-gray-400">Generating your personalized report...</p>
                            <div class="loader mt-4"></div>
                        </div>

                    </div>
                </div>
                <!-- END OF ADDED SCREENING MODAL -->
            </div>

            <div id="chat-view" class="w-full h-full hidden flex">
                <div id="channel-list-panel" class="glass">
                    <div class="p-4 border-b border-white/10 shadow-md flex justify-between items-center">
                        <h2 class="text-lg font-bold truncate">Institute Server</h2>
                        <button id="toggle-channels-btn" title="Toggle Channel List"
                            class="text-gray-400 hover:text-white">
                            <i data-lucide="panel-left-close" class="w-5 h-5"></i>
                        </button>
                    </div>
                    <div id="channel-buttons-container" class="flex-1 p-3 space-y-2 overflow-y-auto"></div>
                    <div id="user-panel" class="p-3 flex items-center gap-3">
                        <div id="chat-profile-pic-container" class="relative">
                            <div id="chat-profile-pic-emoji"
                                class="w-10 h-10 rounded-full bg-gray-700 flex items-center justify-center text-2xl">☘️
                            </div>
                        </div>
                        <span id="chat-user-anonymous-name" class="font-semibold text-sm truncate">Connecting...</span>
                    </div>
                </div>

                <div id="chat-area" class="glass flex-1 flex flex-col min-w-0">
                    <div id="main-chat-header"
                        class="flex items-center justify-between p-4 border-b border-white/10 shadow-sm h-16 flex-shrink-0">
                    </div>
                    <div class="flex flex-1 min-h-0">
                        <div class="flex-1 flex flex-col min-h-0">
                            <div id="main-chat-welcome"
                                class="flex flex-col items-center justify-center h-full text-center p-8">
                                <i data-lucide="message-square" class="w-24 h-24 text-gray-400 opacity-50 mb-4"></i>
                                <h2 class="text-2xl font-bold">Select a channel to begin</h2>
                                <p class="text-gray-300 mt-2">Your conversations will appear here.</p>
                            </div>
                            <div id="main-chat-messages" class="flex-1 overflow-y-auto hidden"></div>
                            <div id="main-chat-input-wrapper" class="hidden p-4 pt-0">
                                <div id="voice-recorder-container"></div>
                                <div id="main-chat-input-container" class="glass relative">
                                    <div id="attachment-menu" class="glass hidden scale-90 opacity-0">
                                        <div class="flex flex-col gap-2">
                                            <button id="attach-image-btn" class="context-menu-item"><i
                                                    data-lucide="image" class="w-4 h-4"></i> Image</button>
                                            <button id="attach-doc-btn" class="context-menu-item"><i
                                                    data-lucide="file-text" class="w-4 h-4"></i> Document</button>
                                            <button id="record-voice-btn" class="context-menu-item"><i data-lucide="mic"
                                                    class="w-4 h-4"></i> Record Voice</button>
                                        </div>
                                    </div>
                                    <button id="attachment-btn" class="p-2 text-gray-400 hover:text-white">
                                        <i data-lucide="plus-circle" class="w-5 h-5"></i>
                                    </button>
                                    <input type="text" id="main-chat-input" placeholder="Type a message..."
                                        class="flex-1">
                                    <button id="emoji-btn" class="p-2 text-gray-400 hover:text-white">
                                        <i data-lucide="smile" class="w-5 h-5"></i>
                                    </button>
                                    <button id="main-chat-send-btn"><i data-lucide="send" class="w-5 h-5"></i></button>
                                    <div id="emoji-panel" class="glass hidden scale-90 opacity-0">
                                        <div class="flex border-b border-white/10">
                                            <button class="emoji-tab active" data-tab="emojis">Emojis</button>
                                            <button class="emoji-tab" data-tab="stickers">Stickers</button>
                                        </div>
                                        <div id="emojis-grid" class="emoji-grid flex-1"></div>
                                        <div id="stickers-grid" class="emoji-grid flex-1 hidden"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div id="members-panel" class="hidden p-2">
                            <div id="member-list-container" class="flex-1 space-y-1 overflow-y-auto"></div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <div id="emote-picker-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center hidden z-50">
        <div class="widget glass p-6 rounded-lg max-w-sm w-full">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-vt323">Choose a new picture</h3>
                <button id="close-emote-modal" class="text-gray-400 hover:text-white">
                    <i data-lucide="x" class="w-6 h-6"></i>
                </button>
            </div>
            <div id="emote-grid" class="grid grid-cols-4 gap-4 text-4xl text-center"></div>
        </div>
    </div>

    <div id="user-profile-popup" class="glass">
        <div id="user-profile-content" class="p-4"></div>
    </div>

    <div id="context-menu" class="glass"></div>

    <div id="image-preview-modal"
        class="fixed inset-0 bg-black/70 flex-col items-center justify-center hidden z-50 p-4">
        <img id="preview-image" src="" alt="Image preview" class="max-w-full max-h-full object-contain rounded-lg">
        <div class="flex gap-2 mt-4 w-full max-w-lg">
            <input type="text" id="image-caption-input" placeholder="Add a caption..."
                class="flex-1 bg-gray-800 text-white p-2 rounded border border-gray-600">
            <button id="send-image-btn" class="bg-green-500 text-white px-4 py-2 rounded">Send</button>
            <button id="cancel-image-btn" class="bg-gray-600 text-white px-4 py-2 rounded">Cancel</button>
        </div>
    </div>
    <input type="file" id="image-upload-input" class="hidden" accept="image/*">
    <input type="file" id="doc-upload-input" class="hidden">


   <script>
        const sidebarToggleBtn = document.getElementById('sidebar-toggle');
        const sidebarOverlay = document.getElementById('sidebar-overlay');
        const serverNavPanel = document.getElementById('server-nav');
        const channelListPanel = document.getElementById('channel-list-panel');

        function openSidebars() {
            if (serverNavPanel) serverNavPanel.classList.add('active');
            if (channelListPanel) channelListPanel.classList.add('active');
            if (sidebarOverlay) sidebarOverlay.classList.remove('hidden');
        }

        function closeSidebars() {
            if (serverNavPanel) serverNavPanel.classList.remove('active');
            if (channelListPanel) channelListPanel.classList.remove('active');
            if (sidebarOverlay) sidebarOverlay.classList.add('hidden');
        }

        if (sidebarToggleBtn) {
            // Make the hamburger button toggle the sidebars
            sidebarToggleBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Check if it's already active to decide whether to open or close
                const isActive = serverNavPanel && serverNavPanel.classList.contains('active');
                if (isActive) {
                    closeSidebars();
                } else {
                    openSidebars();
                }
            });
        }
        
        if (sidebarOverlay) {
            // Make the overlay close them
            sidebarOverlay.addEventListener('click', closeSidebars);
        }
    </script>

    <script type="module">
        import { getDocs, getDoc, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, updateDoc, deleteDoc, setDoc }
            from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- PDF.js Import ---
        // This library allows the browser to read and extract text from PDF files.
        import * as pdfjsLib from "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.mjs";
        pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.mjs";

        // --- IMPORTANT: ACTION REQUIRED ---
        // Replace 'YOUR_..._KEY' with your actual API keys for the features to work.
        const GIPHY_API_KEY = 'D25UbHQ9ZhdSwlwPPLWcc3WUXbS8vzd0';
        const SPOTIFY_CLIENT_ID = '974fb988050a4b52a8dac1b812c8a9e4';
        const YT_MUSIC_CLIENT_ID = '186638354534-sc0ecemspj32eqkqk3u67ma2fe87gfnj.apps.googleusercontent.com';
        const GOOGLE_FIT_CLIENT_ID = '691627541266-nup7p5ked390epqje1vbh4eova6d7lpc.apps.googleusercontent.com';
        const YOUTUBE_API_KEY = 'AIzaSyC4isDfYT5JO64BtH1lvBP0-etVBXhAThA';
        const GEMINI_API_KEY = "AIzaSyBKIy8ScHv6JqVJAMuTibo7ikvBzMSfwXo";

        // --- END OF ACTION REQUIRED ---

        // --- Firebase Setup ---
        const firebaseConfig = {
            apiKey: "AIzaSyCOveO-NFW_X5FkINfh5KMgCBBMlOej8M4",
            authDomain: "student-dashboard-4ec02.firebaseapp.com",
            projectId: "student-dashboard-4ec02",
            storageBucket: "student-dashboard-4ec02.firebasestorage.app",
            messagingSenderId: "250478137189",
            appId: "1:250478137189:web:224352f8e017b4194edb8c",
            measurementId: "G-K159S6DZNP"
        };


        let userProfilesCache = {};
        let unsubscribeFromProfiles = null;
        let unsubscribeFromChannels = null;
        let timeoutInterval = null;

        const finalFirebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig;

        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const sanitizedAppId = appId.replace(/\//g, '_');

        let db, auth, currentUserId, currentUserAnonymousName, currentUserProfile;
        let unsubscribeNotifications = null;
        // --- DOM Element Declarations ---
        const notificationBanner = document.getElementById('notification-banner');
        const notificationMessage = document.getElementById('notification-message');
        const coverElement = document.querySelector('.pixelated-bg');



        // AI Chatbot
        const aiChatToggleBtn = document.getElementById('ai-chat-toggle-btn');
        const aiChatWindow = document.getElementById('ai-chat-window');
        const aiChatCloseBtn = document.getElementById('ai-chat-close-btn');
        const aiChatClearBtn = document.getElementById('ai-chat-clear-btn');
        const aiChatMessages = document.getElementById('ai-chat-messages');
        const aiChatInput = document.getElementById('ai-chat-input');
        const aiChatSendBtn = document.getElementById('ai-chat-send-btn');
        const aiPersonalitySelector = document.getElementById('ai-personality-selector');

        // Assignments
        const assignmentsList = document.getElementById('assignments-list');
        const newAssignmentBtn = document.getElementById('new-assignment-btn');
        const newAssignmentForm = document.getElementById('new-assignment-form');
        const cancelAssignmentBtn = document.getElementById('cancel-assignment-btn');
        const storageToggle = document.getElementById('storage-toggle');

        // --- Custom Notification Logic ---
        document.getElementById('notification-close-btn').addEventListener('click', () => {
            notificationBanner.classList.add('hidden');
        });

        function showNotification(message, type = 'success') {
            notificationMessage.textContent = message;
            notificationBanner.classList.remove('bg-green-500', 'bg-red-500', 'bg-orange-600', 'hidden');
            if (type === 'success') {
                notificationBanner.classList.add('bg-green-500');
            } else { // error
                notificationBanner.classList.add('bg-red-500');
            }
            setTimeout(() => {
                notificationBanner.classList.add('hidden');
            }, 5000); // Auto-hide after 5 seconds
        }

        function generateAnonymousName() {
            const adjectives = ["Brave", "Silent", "Wise", "Wandering", "Gentle", "Hidden", "Cosmic", "Lunar", "Solar", "Pixelated"];
            const nouns = ["River", "Fox", "Oak", "Badger", "Starlight", "Meadow", "Whisper", "Dreamer", "Voyager", "Sprite"];
            const adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
            const noun = nouns[Math.floor(Math.random() * nouns.length)];
            return `${adjective} ${noun}`;
        }

        try {
            const app = initializeApp(finalFirebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
        } catch (e) {
            console.error("Firebase initialization failed. Chat features will be disabled.", e);
        }


        function listenForNotifications(userId) {
            const notificationsRef = collection(db, `artifacts/${sanitizedAppId}/users/${userId}/notifications`);
            const q = query(notificationsRef, orderBy("createdAt", "desc"));

            onSnapshot(q, (snapshot) => {
                const list = document.getElementById("notification-list");
                const badge = document.getElementById("notification-badge");
                list.innerHTML = "";

                let unreadCount = 0;

                snapshot.forEach((doc) => {
                    const data = doc.data();
                    const item = document.createElement("div");
                    item.className = "p-3 border-b border-white/10 text-sm";
                    item.innerHTML = `<strong>${data.title}</strong><p>${data.message}</p>`;
                    list.appendChild(item);

                    if (!data.read) unreadCount++;
                });

                if (unreadCount > 0) {
                    badge.textContent = unreadCount;
                    badge.classList.remove("hidden");
                } else {
                    badge.classList.add("hidden");
                }
            });
        }



        onAuthStateChanged(auth, async (user) => { // <-- Make it async
            if (user) {
                currentUserId = user.uid;
                console.log("Anonymous User ID:", currentUserId);

                // This is the CRITICAL part:
                // We now wait for the profile to exist before doing anything else.
                await ensureUserProfile(user.uid);
                // ensureUserProfile() will handle setting the anonymous name and UI

                // Now that we are sure the user profile exists, we can safely
                // initialize all Firestore listeners and data-dependent widgets.
                listenForNotifications(user.uid);
                listenToAllProfiles();
                listenToChannels();

                initializeAssignments();
                initializeJournaling();
                initializeScreening();
                initializeHealthWidget();
                initAdminNotifications(); // <-- We CALL the function here

            } else {
                // This 'else' block now handles the initial sign-in
                currentUserId = null;
                currentUserAnonymousName = "Guest";
                const userNameElement = document.getElementById('user-anonymous-name');
                if (userNameElement) userNameElement.textContent = currentUserAnonymousName;

                try {
                    if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                        await signInWithCustomToken(auth, __initial_auth_token);
                    } else {
                        await signInAnonymously(auth);
                    }
                } catch (error) {
                    console.error("Initial authentication failed:", error);
                    if (!auth.currentUser) {
                        try {
                            await signInAnonymously(auth);
                        } catch (anonError) {
                            console.error("Fallback anonymous sign-in also failed.", anonError);
                        }
                    }
                }
            }
        });


        // Cover Image Handling
        const GIPHY_GIF_IDS = [
            'HRXnPYf10Zx0wz4alF', // Default best
            '6705G9I9sUcNCaJF10', // Pixel train through nature
            'rzeWnbH8Uc5Y4', // Night castle
            'TRebCjNbc4dIA',      // sky
            'Basrh159dGwKY'  // Pixel night sky
        ];

        async function fetchAndSetCoverGif(apiKey, gifIds) {
            const ids = gifIds.join(',');
            const url = `https://api.giphy.com/v1/gifs?api_key=${apiKey}&ids=${ids}`;
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(`Giphy API error: ${response.statusText}`);
                const data = await response.json();
                if (data.data && data.data.length > 0) {
                    const randomIndex = Math.floor(Math.random() * data.data.length);
                    coverElement.style.backgroundImage = `url('${data.data[randomIndex].images.original.url}')`;
                }
            } catch (error) {
                console.error("Failed to fetch GIFs from Giphy:", error);
                coverElement.style.backgroundImage = `url('https://placehold.co/1200x200/5B6F55/C2C2C2?text=Invalid+Giphy+Key')`;
            }
        }

        function initializePage() {
            if (GIPHY_API_KEY.includes('YOUR_')) {
                coverElement.style.backgroundImage = `url('https://placehold.co/1200x200/5B6F55/C2C2C2?text=Add+Giphy+Key+in+Code')`;
            } else {
                fetchAndSetCoverGif(GIPHY_API_KEY, GIPHY_GIF_IDS);
            }
        }

        // --- Content Flagging Logic ---
        async function checkForSuicidalIntent(text) {
            const prompt = `Analyze the following text for suicidal intent. Respond with only "YES" if it contains clear suicidal ideation, plans, or intent, and "NO" otherwise. Text: "${text}"`;
            const systemInstruction = "You are a content safety classifier. Your only job is to detect suicidal intent. You must only respond with 'YES' or 'NO'.";

            const response = await getGeminiResponse(prompt, systemInstruction);
            // FIX: Check if the response *includes* "YES" to make the check more robust
            // against conversational AI responses (e.g., "Yes, this should be flagged").
            if (response.trim().toUpperCase().includes('YES')) {
                // Let errors from flagUserContent propagate up to the caller.
                await flagUserContent(text);
            }
        }

        function initAdminNotifications() {
            if (!db) {
                console.warn("Firestore not initialized yet - notifications will wait.");
                return;
            }

            // Collection path for admin notifications (change if your backend uses another path)
            const notificationsRef = collection(db, `artifacts/${sanitizedAppId}/public/data/notifications`);

            // Use orderBy if you've imported it; otherwise remove the orderBy bit and sort locally.
            const q = query(notificationsRef, orderBy('createdAt', 'desc'));

            // Listen live
            unsubscribeNotifications = onSnapshot(q, snapshot => {
                const listEl = document.getElementById('notification-list');
                const badgeEl = document.getElementById('notification-badge');

                if (!listEl) return console.warn('No #notification-list element found.');

                // Render items (clear first)
                listEl.innerHTML = '';

                const docs = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));

                // Compute unread count (we mark read by storing currentUserId in readBy array)
                const unreadCount = docs.filter(n => !(Array.isArray(n.readBy) && n.readBy.includes(currentUserId))).length;

                // Update badge
                if (badgeEl) {
                    if (unreadCount > 0) {
                        badgeEl.classList.remove('hidden');
                        badgeEl.textContent = unreadCount > 9 ? '9+' : String(unreadCount);
                    } else {
                        badgeEl.classList.add('hidden');
                    }
                }

                // Render each notification
                docs.forEach(n => {
                    const item = document.createElement('div');
                    item.className = 'p-2 border-b border-white/10 cursor-pointer hover:bg-white/5';
                    const title = n.title || (n.level ? n.level.toUpperCase() : 'Notification');
                    const body = n.body || n.message || '';
                    const ts = n.createdAt && typeof n.createdAt.toDate === 'function' ? n.createdAt.toDate().toLocaleString() : '';

                    item.innerHTML = `
                                        <div class="text-sm font-medium">${title}</div>
                                        <div class="text-xs text-gray-400">${body}</div>
                                        <div class="text-xs text-gray-500 mt-1">${ts}</div>
                                    `;

                    // click: open link (if any) and mark read for this user
                    item.addEventListener('click', async () => {
                        if (n.link) window.open(n.link, '_blank');

                        try {
                            const notifDocRef = doc(db, `artifacts/${sanitizedAppId}/public/data/notifications`, n.id);
                            const newReadBy = Array.from(new Set([...(n.readBy || []), currentUserId]));
                            await updateDoc(notifDocRef, { readBy: newReadBy });
                        } catch (err) {
                            console.error('Failed to mark notification read:', err);
                        }
                    });

                    listEl.appendChild(item);
                });

                // show "no notifications" message if empty
                if (docs.length === 0) {
                    listEl.innerHTML = '<div class="text-center text-gray-400 p-4">No notifications.</div>';
                }
            }, err => {
                console.error('Notification listener error:', err);
            });
        }


        async function flagUserContent(message) {
            if (!db || !currentUserId) {
                throw new Error("User not authenticated. Cannot flag content.");
            }
            try {
                const flaggedUsersRef = collection(db, `artifacts/${sanitizedAppId}/public/data/flagged_users`);
                await addDoc(flaggedUsersRef, {
                    userId: currentUserId,
                    message: message,
                    timestamp: serverTimestamp()
                });
                console.warn(`User content flagged for user: ${currentUserId}`);

                const banner = document.getElementById('notification-banner');
                const messageEl = document.getElementById('notification-message');

                messageEl.innerHTML = `It looks like you're going through a tough time. Help is available. <button id="notification-sos-btn" class="font-bold underline hover:text-yellow-200 ml-2">Open Support Panel</button>`;

                banner.classList.remove('hidden', 'bg-green-500', 'bg-red-500');
                banner.classList.add('bg-orange-600');

                // FIX: Correctly find the new button and add the event listener to open the SOS sidebar.
                document.getElementById('notification-sos-btn').addEventListener('click', () => {
                    document.getElementById('sos-sidebar').classList.remove('translate-x-full');
                });

            } catch (error) {
                console.error("Could not flag user content:", error);
                // FIX: Throw an error to stop the parent function (e.g., saving the journal) and notify the user.
                throw new Error("Could not send alert to administrators.");
            }
        }

        // --- Gemini API Integration ---
        const GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent`;

        async function getGeminiResponse(prompt, customSystemInstruction = null) {
            const defaultSystemInstruction = "You are a helpful assistant.You will act as a companion, a close friend, always chat like a good friend and help the user take out their emotions, help them feel light and vent";
            try {
                if (!GEMINI_API_KEY || GEMINI_API_KEY.includes('YOUR_')) {
                    return "Sorry, the AI Assistant is not configured. Please add a Gemini API Key in the code.";
                }
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }],
                    systemInstruction: { parts: [{ text: customSystemInstruction || defaultSystemInstruction }] },
                };
                const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    // FIX: Improved error handling to get detailed messages from the API response body.
                    const errorData = await response.json().catch(() => null);
                    const errorMessage = errorData?.error?.message || response.statusText;
                    throw new Error(`API error (${response.status}): ${errorMessage}`);
                }
                const result = await response.json();
                return result.candidates?.[0]?.content?.parts?.[0]?.text || "No response found.";
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                // FIX: Return the detailed error message to the user for easier debugging.
                return `Sorry, something went wrong. Please check the console for details. Error: ${error.message}`;
            }
        }

        // --- Guided Meditation Logic ---
        function initializeMeditationWidget() {
            const topicInput = document.getElementById('meditation-topic-input');
            const languageSelect = document.getElementById('meditation-language-select');
            const languageSearch = document.getElementById('meditation-language-search');
            const generateBtn = document.getElementById('generate-meditation-btn');
            const playBtn = document.getElementById('play-meditation-btn');
            const scriptContainer = document.getElementById('meditation-script-container');
            const audioPlayer = document.getElementById('meditation-audio-player');
            const quickMeditationBtn = document.getElementById('quick-meditation-sos-btn');
            const breathingExerciseBtn = document.getElementById('breathing-exercise-sos-btn');
            const clearBtn = document.getElementById('clear-meditation-btn');
            const toggleBtn = document.getElementById('toggle-meditation-btn');
            const meditationBody = document.getElementById('meditation-widget-body');

            let lastUsedLanguage = localStorage.getItem('lastMeditationLanguage') || 'English (India)';

            function setInitialLanguage() {
                const options = Array.from(languageSelect.options).map(opt => opt.value);
                if (options.includes(lastUsedLanguage)) {
                    languageSelect.value = lastUsedLanguage;
                } else {
                    languageSelect.value = 'other';
                    languageSearch.classList.remove('hidden');
                    languageSearch.value = lastUsedLanguage;
                }
            }

            languageSelect.addEventListener('change', () => {
                if (languageSelect.value === 'other') {
                    languageSearch.classList.remove('hidden');
                } else {
                    languageSearch.classList.add('hidden');
                }
            });

            async function generateScript() {
                const topic = topicInput.value.trim();
                let language = languageSelect.value;
                if (language === 'other') {
                    language = languageSearch.value.trim();
                }

                if (!topic || !language) {
                    showNotification("Please provide a topic and language.", "error");
                    return;
                }

                localStorage.setItem('lastMeditationLanguage', language);
                lastUsedLanguage = language;

                generateBtn.disabled = true;
                generateBtn.innerHTML = '<div class="loader" style="width:20px; height:20px; border-width: 2px; margin: auto;"></div>';
                scriptContainer.classList.remove('hidden');
                scriptContainer.innerHTML = '<div class="loader"></div>';
                playBtn.disabled = true;
                audioPlayer.classList.add('hidden');


                const prompt = `Generate a short (around 150 words), calming guided meditation script in the ${language} language about "${topic}". The script should be easy to follow and soothing.`;
                const systemInstruction = "You are a meditation guide. You create peaceful and serene meditation scripts. Do not include any introductory or concluding remarks outside of the script itself.";

                const script = await getGeminiResponse(prompt, systemInstruction);

                scriptContainer.textContent = script;
                generateBtn.disabled = false;
                generateBtn.innerHTML = 'Generate Script';
                playBtn.disabled = false;
            }

            async function playAudio() {
                const script = scriptContainer.textContent;
                if (!script) {
                    showNotification("Please generate a script first.", "error");
                    return;
                }

                playBtn.disabled = true;
                playBtn.innerHTML = '<div class="loader" style="width:20px; height:20px; border-width: 2px; margin: auto;"></div>';

                // --- START OF CHANGE ---
                // FIX: Removed the explicit language from the TTS prompt.
                // The model will now auto-detect the language from the script itself,
                // which allows custom languages to be synthesized correctly.
                const ttsPrompt = `Say in a calm, slow, and soothing voice: ${script}`;
                // --- END OF CHANGE ---

                try {
                    const audioData = await fetchTTS(ttsPrompt);
                    if (audioData) {
                        const pcmData = base64ToArrayBuffer(audioData);
                        const pcm16 = new Int16Array(pcmData);
                        const wavBlob = pcmToWav(pcm16, 24000);
                        const audioUrl = URL.createObjectURL(wavBlob);

                        audioPlayer.src = audioUrl;
                        audioPlayer.controls = true;
                        audioPlayer.classList.remove('hidden');
                        audioPlayer.play();
                    } else {
                        showNotification("Could not generate audio. Please try again.", "error");
                    }
                } catch (error) {
                    showNotification("An error occurred while generating audio.", "error");
                    console.error("TTS Error:", error);
                } finally {
                    playBtn.disabled = false;
                    playBtn.innerHTML = 'Play Meditation';
                }
            }

            async function fetchTTS(prompt) {
                const TTS_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${GEMINI_API_KEY}`;
                const payload = {
                    model: "gemini-2.5-flash-preview-tts",
                    contents: [{ parts: [{ text: prompt }] }],
                    generationConfig: { responseModalities: ["AUDIO"] },
                };
                try {
                    const response = await fetch(TTS_API_URL, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                    });
                    if (!response.ok) throw new Error(`API error: ${response.statusText}`);
                    const result = await response.json();
                    return result.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
                } catch (error) {
                    console.error("Error calling TTS API:", error);
                    return null;
                }
            }

            function base64ToArrayBuffer(base64) {
                const binaryString = window.atob(base64);
                const len = binaryString.length;
                const bytes = new Uint8Array(len);
                for (let i = 0; i < len; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            }

            function pcmToWav(pcmData, sampleRate) {
                const numChannels = 1;
                const bitsPerSample = 16;
                const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
                const blockAlign = numChannels * (bitsPerSample / 8);
                const dataSize = pcmData.length * (bitsPerSample / 8);
                const fileSize = 36 + dataSize;

                const buffer = new ArrayBuffer(44 + dataSize);
                const view = new DataView(buffer);

                writeString(view, 0, 'RIFF');
                view.setUint32(4, fileSize, true);
                writeString(view, 8, 'WAVE');
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, byteRate, true);
                view.setUint16(32, blockAlign, true);
                view.setUint16(34, bitsPerSample, true);
                writeString(view, 36, 'data');
                view.setUint32(40, dataSize, true);

                for (let i = 0; i < pcmData.length; i++) {
                    view.setInt16(44 + i * 2, pcmData[i], true);
                }

                return new Blob([view], { type: 'audio/wav' });
            }

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            toggleBtn.addEventListener('click', () => {
                meditationBody.classList.toggle('hidden');
                if (meditationBody.classList.contains('hidden')) {
                    toggleBtn.innerHTML = '<i data-lucide="chevron-down" class="w-5 h-5"></i>';
                    toggleBtn.title = "Expand";
                } else {
                    toggleBtn.innerHTML = '<i data-lucide="chevron-up" class="w-5 h-5"></i>';
                    toggleBtn.title = "Minimize";
                }
                lucide.createIcons();
            });

            clearBtn.addEventListener('click', () => {
                topicInput.value = '';
                scriptContainer.textContent = '';
                scriptContainer.classList.add('hidden');
                audioPlayer.src = '';
                audioPlayer.classList.add('hidden');
                playBtn.disabled = true;
            });

            quickMeditationBtn.addEventListener('click', () => {
                topicInput.value = "5-minute calming meditation";
                setInitialLanguage();
                generateScript();
                document.getElementById('sos-sidebar').classList.add('translate-x-full');
            });

            breathingExerciseBtn.addEventListener('click', () => {
                topicInput.value = "Guided box breathing exercise for focus";
                setInitialLanguage();
                generateScript();
                document.getElementById('sos-sidebar').classList.add('translate-x-full');
            });

            generateBtn.addEventListener('click', generateScript);
            playBtn.addEventListener('click', playAudio);

            setInitialLanguage();
        }

        // --- Helpful Link Logic ---
        const helpfulLinkBtn = document.getElementById('helpful-link-btn');
        const helpfulLinksList = document.getElementById('helpful-links-list');

        helpfulLinkBtn.addEventListener('click', async () => {
            const prompt = "Generate a single, helpful and meaningful link for a student looking to improve their well-being or productivity. Provide only the URL and a very short description, separated by a pipe |. For example: `https://www.example.com | A site for mindfulness`";
            helpfulLinkBtn.disabled = true;
            helpfulLinkBtn.textContent = 'Finding...';
            const response = await getGeminiResponse(prompt);

            const parts = response.split('|');
            if (parts.length === 2) {
                const url = parts[0].trim();
                const description = parts[1].trim();
                const newListItem = document.createElement('li');
                newListItem.innerHTML = `<a href="${url}" target="_blank" class="hover:text-green-400">✧ ${description}</a>`;
                helpfulLinksList.appendChild(newListItem);
            } else {
                console.warn("Could not parse helpful link response:", response);
            }

            helpfulLinkBtn.disabled = false;
            helpfulLinkBtn.textContent = '✨ Find a Link';
        });

        // --- Peer Chat Logic ---

        const USE_MOCK_FIRESTORE = false;

        let mockDbInstance;
        const mockListeners = {};

        function getMockDb() {
            if (!mockDbInstance) {
                try {
                    const savedDb = localStorage.getItem('mockFirestoreDb');
                    mockDbInstance = savedDb ? JSON.parse(savedDb) : {};
                } catch (e) { mockDbInstance = {}; }
            }
            if (!mockDbInstance.channels) {
                mockDbInstance.channels = {
                    'general-chat': { name: 'General Chat', id: 'general-chat', icon: 'hash' },
                    'study-group': { name: 'Study Group', id: 'study-group', icon: 'book-open' },
                    'gaming-corner': { name: 'Gaming Corner', id: 'gaming-corner', icon: 'gamepad-2' }
                };
                saveMockDb();
            }
            return mockDbInstance;
        }

        function saveMockDb() {
            localStorage.setItem('mockFirestoreDb', JSON.stringify(mockDbInstance));
        }

        function notifyListeners(path) {
            Object.keys(mockListeners).forEach(listenerPath => {
                if (path.startsWith(listenerPath)) {
                    mockListeners[listenerPath].forEach(callback => {
                        callback({ docs: getCollectionDocs(listenerPath) });
                    });
                }
            });
        }

        function getCollectionDocs(path) {
            const db = getMockDb();
            const parts = path.split('/');
            let current = db;
            for (const part of parts) {
                if (!current[part]) return [];
                current = current[part];
            }
            return Object.keys(current).map(id => ({ id, data: () => ({ ...current[id] }) }));
        }

        const mockFirestore = {
            getDoc: async (path) => {
                const db = getMockDb();
                const parts = path.split('/');
                let current = db;
                for (let i = 0; i < parts.length; i++) {
                    if (!current[parts[i]]) return { exists: () => false, data: () => null };
                    current = current[parts[i]];
                }
                return { exists: () => true, data: () => current };
            },
            setDoc: async (path, data, options = {}) => {
                const db = getMockDb();
                const parts = path.split('/');
                let current = db;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!current[parts[i]]) current[parts[i]] = {};
                    current = current[parts[i]];
                }
                const docId = parts[parts.length - 1];
                if (options.merge) {
                    current[docId] = { ...(current[docId] || {}), ...data };
                } else {
                    current[docId] = data;
                }
                saveMockDb();
                notifyListeners(path.substring(0, path.lastIndexOf('/')));
            },
            addDoc: async (path, data) => {
                const docId = `mock_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                const newPath = `${path}/${docId}`;
                await mockFirestore.setDoc(newPath, data);
                return newPath;
            },
            deleteDoc: async (path) => {
                const db = getMockDb();
                const parts = path.split('/');
                let current = db;
                for (let i = 0; i < parts.length - 1; i++) {
                    if (!current[parts[i]]) return;
                    current = current[parts[i]];
                }
                const docId = parts[parts.length - 1];
                delete current[docId];
                saveMockDb();
                notifyListeners(path.substring(0, path.lastIndexOf('/')));
            },
            onSnapshot: (path, callback) => {
                if (!mockListeners[path]) mockListeners[path] = [];
                mockListeners[path].push(callback);
                callback({ docs: getCollectionDocs(path) });
                return () => {
                    mockListeners[path] = mockListeners[path].filter(cb => cb !== callback);
                };
            },
            serverTimestamp: () => new Date().toISOString()
        };

        const mockAuth = {
            onAuthStateChanged: (callback) => {
                let userId = localStorage.getItem('mockUserId');
                if (!userId) {
                    userId = `mock_user_${Date.now()}`;
                    localStorage.setItem('mockUserId', userId);
                }
                callback({ uid: userId });
            }
        };

        // import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        // import { getAuth, signInAnonymously, onAuthStateChanged, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        // import { getFirestore, collection, addDoc, query, onSnapshot, serverTimestamp, doc, orderBy, setDoc, getDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // const firebaseConfig = { apiKey: "YOUR_API_KEY", authDomain: "YOUR_AUTH_DOMAIN", projectId: "YOUR_PROJECT_ID", storageBucket: "YOUR_STORAGE_BUCKET", messagingSenderId: "YOUR_MESSAGING_SENDER_ID", appId: "YOUR_APP_ID" };
        // const sanitizedAppId = 'default-app-id'.replace(/\//g, '_');

        // let db, auth, currentUserId, currentUserAnonymousName, currentUserProfile;

        if (!USE_MOCK_FIRESTORE) {
            try {
                const finalFirebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : firebaseConfig;
                const app = initializeApp(finalFirebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
            } catch (e) { console.error("Firebase initialization failed.", e); }
        }

        const dashboardView = document.getElementById('dashboard-view');
        const chatView = document.getElementById('chat-view');
        const mainChatHeader = document.getElementById('main-chat-header');
        const mainChatWelcome = document.getElementById('main-chat-welcome');
        const mainChatMessages = document.getElementById('main-chat-messages');
        const mainChatInputWrapper = document.getElementById('main-chat-input-wrapper');
        const mainChatInput = document.getElementById('main-chat-input');
        const mainChatSendBtn = document.getElementById('main-chat-send-btn');

        const dashboardProfilePicContainer = document.getElementById('profile-pic-container');
        const dashboardProfilePicEmoji = document.getElementById('profile-pic-emoji');
        const chatProfilePicEmoji = document.getElementById('chat-profile-pic-emoji');
        const userProfilePopup = document.getElementById('user-profile-popup');
        const userProfileContent = document.getElementById('user-profile-content');
        const channelListPanel = document.getElementById('channel-list-panel');
        const membersPanel = document.getElementById('members-panel');
        const memberListContainer = document.getElementById('member-list-container');
        const contextMenu = document.getElementById('context-menu');
        const channelButtonsContainer = document.getElementById('channel-buttons-container');

        // let userProfilesCache = {};
        // let unsubscribeFromProfiles = null;
        // let unsubscribeFromChannels = null;
        // let timeoutInterval = null;

        // async function handleAuthentication() {
        //     if (USE_MOCK_FIRESTORE) {
        //         mockAuth.onAuthStateChanged(async (user) => {
        //             currentUserId = user.uid;
        //             await ensureUserProfile(user.uid);
        //             listenToAllProfiles();
        //             listenToChannels();
        //         });
        //     } else {
        //         onAuthStateChanged(auth, async (user) => {
        //             if (user) {
        //                 currentUserId = user.uid;
        //                 await ensureUserProfile(user.uid);
        //                 listenToAllProfiles();
        //                 listenToChannels();
        //             } else {
        //                 if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
        //                     await signInWithCustomToken(auth, __initial_auth_token);
        //                 } else {
        //                     await signInAnonymously(auth);
        //                 }
        //             }
        //         });
        //     }
        // }

        async function ensureUserProfile(userId) {
            const profilePath = `artifacts/${sanitizedAppId}/public/data/profiles/${userId}`;
            try {
                const profileRef = doc(db, profilePath);
                const profileSnap = await getDoc(profileRef);

                if (!profileSnap.exists()) {
                    const name = generateAnonymousName();
                    const profilesCollectionRef = collection(db, `artifacts/${sanitizedAppId}/public/data/profiles`);
                    const isFirstUser = (await getDocs(profilesCollectionRef)).empty;
                    const profileData = { userId, name, profilePic: '☘️', role: isFirstUser ? 'owner' : 'member', joinedAt: serverTimestamp() };
                    await setDoc(profileRef, profileData);
                    currentUserProfile = profileData;
                } else {
                    currentUserProfile = profileSnap.data();
                }

                // --- NEW ROLE-BASED ACCESS LOGIC ---
                if (currentUserProfile.role === 'admin') {
                    // If the user is an admin, hide the student UI and show a message.
                    document.body.innerHTML = `
                <div class="w-screen h-screen flex flex-col items-center justify-center text-center p-8 bg-[#1a202c] text-white">
                    <i data-lucide="shield-alert" class="w-16 h-16 text-red-400 mb-4"></i>
                    <h1 class="text-3xl font-bold">Access Denied</h1>
                    <p class="text-lg text-gray-300 mt-2">Your 'admin' role is intended for the Admin Dashboard only.</p>
                    <p class="text-gray-400 mt-1">Please use the separate Admin Dashboard link to access flagged user reports.</p>
                </div>
            `;
                    lucide.createIcons();
                    return; // Stop further execution for admins
                }
                // --- END OF NEW LOGIC ---

                currentUserAnonymousName = currentUserProfile.name;
                updateUserUI(currentUserAnonymousName, currentUserProfile.profilePic);
                checkAndUpdateTimeoutState(); // This will now only run for non-admins

            } catch (error) {
                console.error("Fatal Error: Could not read or create user profile.", error);
                document.body.innerHTML = `<div class="w-screen h-screen flex items-center justify-center bg-red-900 text-white p-8 text-center"><h1 class="text-2xl">Fatal Connection Error</h1><p>Could not load user profile. Check Firestore rules and database connection.</p></div>`;
            }
        }
        function updateUserUI(name, pic) {
            document.getElementById('user-anonymous-name').textContent = name;
            document.getElementById('chat-user-anonymous-name').textContent = name;
            dashboardProfilePicEmoji.textContent = pic;
            chatProfilePicEmoji.textContent = pic;
        }


        function initializeViewSwitcher() {
            const serverBtns = document.querySelectorAll('.server-btn');
            serverBtns.forEach(btn => {
                btn.addEventListener('click', () => {
                    serverBtns.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    const view = btn.dataset.view;
                    userProfilePopup.classList.remove('show');
                    if (view === 'dashboard') {
                        dashboardView.classList.remove('hidden');
                        chatView.classList.add('hidden');
                    } else {
                        dashboardView.classList.add('hidden');
                        chatView.classList.remove('hidden');
                    }
                });
            });
            document.getElementById('toggle-channels-btn').addEventListener('click', () => {
                channelListPanel.classList.toggle('hidden');
            });
        }

        let currentChatRoomId = null;
        let unsubscribeFromMessages = null;

        function initializePeerChat() {
            mainChatSendBtn.addEventListener('click', handlePeerSendMessage);
            mainChatInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handlePeerSendMessage(); });

            mainChatMessages.addEventListener('click', (e) => {
                const userTarget = e.target.closest('[data-userid]');
                const deleteTarget = e.target.closest('.delete-message-btn');
                if (userTarget) {
                    showUserProfile(userTarget.dataset.userid, userTarget);
                }
                if (deleteTarget) {
                    if (confirm('Are you sure you want to delete this message?')) {
                        handleDeleteMessage(deleteTarget.dataset.msgId);
                    }
                }
            });
            mainChatMessages.addEventListener('contextmenu', (e) => {
                const userTarget = e.target.closest('[data-userid]');
                if (userTarget) {
                    showContextMenu(e, userTarget.dataset.userid);
                }
            });
        }

        async function joinChatRoom(roomId, roomName) {
            if (unsubscribeFromMessages) unsubscribeFromMessages();
            if (!currentUserId) return;

            currentChatRoomId = roomId;
            mainChatHeader.innerHTML = `
                <h3 class="text-lg font-semibold flex items-center gap-2"><i data-lucide="hash" class="w-6 h-6 text-gray-400"></i> ${roomName}</h3>
                <button id="toggle-members-btn" title="Toggle Members List" class="text-gray-400 hover:text-white">
                    <i data-lucide="users" class="w-5 h-5"></i>
                </button>
            `;
            document.getElementById('toggle-members-btn').addEventListener('click', () => {
                membersPanel.classList.toggle('hidden');
            });

            const isNoticesChannel = roomId === 'notices';
            // This correctly allows ONLY owners and moderators to post
            const canPostInNotices = currentUserProfile.role === 'owner' || currentUserProfile.role === 'moderator';
            if (isNoticesChannel && !canPostInNotices) {
                mainChatInput.disabled = true;
                mainChatInput.placeholder = "Only Owners and Moderators can post in this channel.";
            } else {
                // This is crucial: it re-enables the input for other channels while still checking for timeouts.
                checkAndUpdateTimeoutState();
            }

            mainChatWelcome.classList.add('hidden');
            mainChatMessages.classList.remove('hidden');
            mainChatInputWrapper.classList.remove('hidden');
            membersPanel.classList.remove('hidden');
            mainChatMessages.innerHTML = '';
            lucide.createIcons();

            const messagesPath = `artifacts/${sanitizedAppId}/public/data/chatrooms/${currentChatRoomId}/messages`;
            const onSnapshotFn = USE_MOCK_FIRESTORE ? mockFirestore.onSnapshot : onSnapshot;
            const messagesRef = USE_MOCK_FIRESTORE ? messagesPath : query(collection(db, messagesPath), orderBy("createdAt"));

            unsubscribeFromMessages = onSnapshotFn(messagesRef, async (snapshot) => {
                const messagesData = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                messagesData.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));

                const senderIds = [...new Set(messagesData.map(m => m.senderId))];
                const profilesToFetch = senderIds.filter(id => !userProfilesCache[id]);

                if (profilesToFetch.length > 0) {
                    await Promise.all(profilesToFetch.map(async id => {
                        const profilePath = `artifacts/${sanitizedAppId}/public/data/profiles/${id}`;
                        const getDocFn = USE_MOCK_FIRESTORE ? mockFirestore.getDoc : getDoc;
                        const profileRef = USE_MOCK_FIRESTORE ? profilePath : doc(db, profilePath);
                        const profileSnap = await getDocFn(profileRef);
                        if (profileSnap.exists()) userProfilesCache[id] = profileSnap.data();
                    }));
                }

                mainChatMessages.innerHTML = '';
                let lastSenderId = null;
                messagesData.forEach(message => {
                    const isSameSender = lastSenderId === message.senderId;
                    displayPeerChatMessage(message, isSameSender);
                    lastSenderId = message.senderId;
                });
                mainChatMessages.scrollTop = mainChatMessages.scrollHeight;
            });
        }

        function displayPeerChatMessage(messageData, isSameSender) {
            const senderProfile = userProfilesCache[messageData.senderId] || { name: 'Unknown User', profilePic: '👤', role: 'member' };
            const isCurrentUser = messageData.senderId === currentUserId;

            const messageContainer = document.createElement('div');
            messageContainer.className = 'chat-message';
            if (isSameSender) messageContainer.classList.add('is-consecutive');

            const timeString = new Date(messageData.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }) || '';
            const avatarHTML = `<div class="chat-avatar ${isSameSender ? 'is-placeholder' : ''}" data-userid="${messageData.senderId}">${senderProfile.profilePic}</div>`;
            const roleIcons = { owner: `<i data-lucide="crown" class="w-4 h-4 text-amber-400" title="Owner"></i>`, moderator: `<i data-lucide="shield" class="w-4 h-4 text-blue-400" title="Moderator"></i>` };
            const roleBadge = roleIcons[senderProfile.role] || '';

            let messageContentHTML = '';

            const messageBody = () => {
                switch (messageData.type) {
                    case 'image':
                        return `<img src="${messageData.content}" alt="User image" class="chat-image"><p class="chat-text">${messageData.caption || ''}</p>`;
                    case 'audio':
                        if (!messageData.content) {
                            console.warn('Audio message without content:', messageData);
                            return `<div class="chat-text text-sm text-red-400">[Audio unavailable]</div>`;
                        }
                        return `<audio controls src="${messageData.content}" class="w-full max-w-sm" preload="metadata"></audio>`;

                    case 'document':
                        return `<div class="document-bubble"><i data-lucide="file-text" class="w-8 h-8 text-gray-400"></i><span class="font-semibold truncate">${messageData.fileName}</span></div>`;
                    case 'sticker':
                        return `<div class="text-6xl">${messageData.content}</div>`;
                    default:
                        return `<div class="chat-text">${messageData.text}</div>`;
                }
            };

            if (isSameSender) {
                messageContentHTML = messageBody();
                messageContainer.innerHTML = messageContentHTML;
            } else {
                messageContentHTML = `
                    <div>
                        <div class="chat-sender-info">
                            <span class="chat-sender-name ${isCurrentUser ? 'user' : ''}" data-userid="${messageData.senderId}">${isCurrentUser ? 'You' : senderProfile.name}</span>
                            <span class="role-badge">${roleBadge}</span>
                            <span class="chat-timestamp">${timeString}</span>
                        </div>
                        ${messageBody()}
                    </div>`;
                messageContainer.innerHTML = avatarHTML + messageContentHTML;
            }

            const canDelete = currentUserProfile.role === 'owner' || currentUserProfile.role === 'moderator';
            if (canDelete) {
                const actionsHTML = `<div class="message-actions">
                    <button class="delete-message-btn p-1 text-gray-400 hover:text-red-400" data-msg-id="${messageData.id}"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
                </div>`;
                messageContainer.innerHTML += actionsHTML;
            }
            mainChatMessages.appendChild(messageContainer);

            lucide.createIcons({ nodes: [messageContainer] });
        }

        async function sendMessage(messageData) {
            if (!currentChatRoomId || !currentUserId) return;
            const finalMessage = {
                ...messageData,
                senderId: currentUserId,
                createdAt: USE_MOCK_FIRESTORE ? mockFirestore.serverTimestamp() : serverTimestamp()
            };

            const messagesPath = `artifacts/${sanitizedAppId}/public/data/chatrooms/${currentChatRoomId}/messages`;
            const addDocFn = USE_MOCK_FIRESTORE ? mockFirestore.addDoc : addDoc;
            const collectionRef = USE_MOCK_FIRESTORE ? messagesPath : collection(db, messagesPath);

            try {
                await addDocFn(collectionRef, finalMessage);
            } catch (error) {
                console.error("Error sending message:", error);
            }
        }

        async function handlePeerSendMessage() {
            if (currentUserProfile && currentUserProfile.timeoutUntil && new Date(currentUserProfile.timeoutUntil) > new Date()) return;

            const userInput = mainChatInput.value.trim();
            if (!userInput) return;

            mainChatSendBtn.disabled = true;
            await sendMessage({ type: 'text', text: userInput });
            mainChatInput.value = '';
            mainChatSendBtn.disabled = false;
        }

        async function handleDeleteMessage(messageId) {
            if (!currentChatRoomId) return;
            const messagePath = `artifacts/${sanitizedAppId}/public/data/chatrooms/${currentChatRoomId}/messages/${messageId}`;
            const deleteDocFn = USE_MOCK_FIRESTORE ? mockFirestore.deleteDoc : deleteDoc;
            try { await deleteDocFn(messagePath); } catch (error) { console.error("Error deleting message: ", error); }
        }

        function listenToAllProfiles() {
            if (unsubscribeFromProfiles) unsubscribeFromProfiles();
            const profilesPath = `artifacts/${sanitizedAppId}/public/data/profiles`;
            const onSnapshotFn = USE_MOCK_FIRESTORE ? mockFirestore.onSnapshot : onSnapshot;
            const collectionRef = USE_MOCK_FIRESTORE ? profilesPath : collection(db, profilesPath);
            unsubscribeFromProfiles = onSnapshotFn(collectionRef, (snapshot) => {
                const allProfiles = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                allProfiles.forEach(p => {
                    userProfilesCache[p.id] = p;
                    if (p.id === currentUserId) {
                        currentUserProfile = p;
                        checkAndUpdateTimeoutState();
                    }
                });
                renderMembersList(allProfiles);
            });
        }

        function renderMembersList(profiles) {
            const roles = { owner: [], moderator: [], member: [] };
            profiles.forEach(p => { (roles[p.role] || roles.member).push(p); });
            const roleOrder = ['owner', 'moderator', 'member'];
            memberListContainer.innerHTML = '';
            roleOrder.forEach(role => {
                const members = roles[role];
                if (members.length > 0) {
                    const roleHeader = `<h3 class="text-xs font-bold uppercase text-gray-400 px-2 mt-4 mb-2">${role} - ${members.length}</h3>`;
                    const membersHTML = members.map(member => {
                        const isTimedOut = member.timeoutUntil && new Date(member.timeoutUntil) > new Date();
                        return `
                        <div class="member-list-item w-full text-left p-2 rounded transition-colors flex items-center gap-3" data-userid="${member.userId}">
                            <div class="w-8 h-8 rounded-full bg-gray-700 flex items-center justify-center text-xl flex-shrink-0">${member.profilePic}</div>
                            <span class="truncate font-medium flex-1">${member.name}</span>
                            ${isTimedOut ? '<i data-lucide="timer" class="w-4 h-4 text-gray-400" title="In Timeout"></i>' : ''}
                        </div>
                     `}).join('');
                    memberListContainer.innerHTML += roleHeader + membersHTML;
                }
            });
            lucide.createIcons({ nodes: [memberListContainer] });
        }

        function initializeUserProfilePopup() {
            document.addEventListener('click', (event) => {
                if (event.target.closest('.chat-avatar, .chat-sender-name, .member-list-item')) return;
                if (!userProfilePopup.contains(event.target)) userProfilePopup.classList.remove('show');
            });
        }

        function showUserProfile(userId, targetElement) {
            const profile = userProfilesCache[userId];
            if (!profile || !currentUserProfile) return;

            const roleColors = { owner: 'text-amber-400', moderator: 'text-blue-400', member: 'text-gray-400' };
            const roleColor = roleColors[profile.role] || 'text-gray-400';
            const joinDate = new Date(profile.joinedAt).toLocaleDateString() || 'N/A';

            userProfileContent.innerHTML = `
                <div class="flex flex-col items-center text-center">
                    <div class="w-24 h-24 rounded-full bg-gray-700 flex items-center justify-center text-6xl mb-4">${profile.profilePic}</div>
                    <h3 class="text-2xl font-bold">${profile.name}</h3>
                    <p class="${roleColor} font-semibold capitalize">${profile.role}</p>
                    <div class="mt-4 w-full text-left">
                        <div class="bg-black/20 p-3 rounded-lg">
                            <h4 class="text-sm text-gray-400 font-bold uppercase">Member Since</h4>
                            <p>${joinDate}</p>
                        </div>
                    </div>
                </div>`;

            lucide.createIcons({ nodes: [userProfileContent] });

            const rect = targetElement.getBoundingClientRect();
            let top = rect.bottom + 8;
            let left = rect.left;
            if (left + 300 > window.innerWidth - 16) left = window.innerWidth - 300 - 16;
            const popupHeight = 250;
            if (top + popupHeight > window.innerHeight - 16) top = rect.top - popupHeight - 8;

            userProfilePopup.style.top = `${top}px`;
            userProfilePopup.style.left = `${left}px`;
            userProfilePopup.classList.add('show');
        }

        function initializeContextMenu() {
            document.addEventListener('click', () => contextMenu.classList.remove('show'));
            document.addEventListener('contextmenu', () => contextMenu.classList.remove('show'));
            contextMenu.addEventListener('click', e => e.stopPropagation());
            channelButtonsContainer.addEventListener('contextmenu', e => showChannelContextMenu(e));

            memberListContainer.addEventListener('click', e => {
                const target = e.target.closest('.member-list-item');
                if (target) {
                    showUserProfile(target.dataset.userid, target);
                }
            });
            memberListContainer.addEventListener('contextmenu', e => {
                const target = e.target.closest('.member-list-item');
                if (target) {
                    showContextMenu(e, target.dataset.userid);
                }
            });
        }

        function showContextMenu(event, userId) {
            event.preventDefault();
            event.stopPropagation();
            const targetProfile = userProfilesCache[userId];
            if (!targetProfile || !currentUserProfile) return;

            let menuItemsHTML = `<div class="context-menu-item" data-action="profile" data-userid="${userId}"><i data-lucide="user" class="w-4 h-4"></i> View Profile</div>`;
            let modActionsHTML = '';

            if (currentUserProfile.role === 'owner' && userId !== currentUserId && targetProfile.role !== 'owner') {
                if (targetProfile.role === 'member') {
                    modActionsHTML += `<div class="context-menu-item" data-action="promote" data-userid="${userId}"><i data-lucide="shield-plus" class="w-4 h-4"></i> Promote to Moderator</div>`;
                } else if (targetProfile.role === 'moderator') {
                    modActionsHTML += `<div class="context-menu-item" data-action="demote" data-userid="${userId}"><i data-lucide="shield-minus" class="w-4 h-4"></i> Demote to Member</div>`;
                }
            }
            if ((currentUserProfile.role === 'owner' || currentUserProfile.role === 'moderator') && targetProfile.role === 'member' && userId !== currentUserId) {
                modActionsHTML += `<div class="context-menu-item" data-action="timeout" data-userid="${userId}"><i data-lucide="timer" class="w-4 h-4"></i> Timeout User</div>`;
                modActionsHTML += `<div class="context-menu-item danger" data-action="kick" data-userid="${userId}"><i data-lucide="user-x" class="w-4 h-4"></i> Kick User</div>`;
            }

            if (modActionsHTML) {
                menuItemsHTML += `<div class="context-menu-separator"></div>${modActionsHTML}`;
            }

            contextMenu.innerHTML = menuItemsHTML;
            lucide.createIcons({ nodes: [contextMenu] });

            let left = event.pageX;
            let top = event.pageY;
            if (left + 220 > window.innerWidth) left -= 220;
            if (top + contextMenu.offsetHeight > window.innerHeight) top -= contextMenu.offsetHeight;

            contextMenu.style.left = `${left}px`;
            contextMenu.style.top = `${top}px`;
            contextMenu.classList.add('show');

            contextMenu.querySelector('[data-action="profile"]')?.addEventListener('click', e => showUserProfile(e.currentTarget.dataset.userid, event.target));
            contextMenu.querySelector('[data-action="promote"]')?.addEventListener('click', e => updateUserRole(e.currentTarget.dataset.userid, 'moderator'));
            contextMenu.querySelector('[data-action="demote"]')?.addEventListener('click', e => updateUserRole(e.currentTarget.dataset.userid, 'member'));
            contextMenu.querySelector('[data-action="kick"]')?.addEventListener('click', e => kickUser(e.currentTarget.dataset.userid));
            contextMenu.querySelector('[data-action="timeout"]')?.addEventListener('click', e => timeoutUser(e.currentTarget.dataset.userid));
        }

        function showChannelContextMenu(event) {
            event.preventDefault();
            event.stopPropagation();
            if (currentUserProfile.role !== 'owner') return;

            const targetChannel = event.target.closest('.channel-btn');
            let menuItemsHTML = `<div class="context-menu-item" data-action="add-channel"><i data-lucide="plus" class="w-4 h-4"></i> Create Channel</div>`;
            if (targetChannel && targetChannel.dataset.channelId !== 'notices') {
                menuItemsHTML += `<div class="context-menu-item danger" data-action="delete-channel" data-channel-id="${targetChannel.dataset.channelId}" data-channel-name="${targetChannel.dataset.roomName}"><i data-lucide="trash-2" class="w-4 h-4"></i> Delete Channel</div>`;
            }
            contextMenu.innerHTML = menuItemsHTML;
            lucide.createIcons({ nodes: [contextMenu] });

            let left = event.pageX;
            let top = event.pageY;
            if (left + 220 > window.innerWidth) left -= 220;
            if (top + contextMenu.offsetHeight > window.innerHeight) top -= contextMenu.offsetHeight;

            contextMenu.style.left = `${left}px`;
            contextMenu.style.top = `${top}px`;
            contextMenu.classList.add('show');

            contextMenu.querySelector('[data-action="add-channel"]')?.addEventListener('click', addChannel);
            contextMenu.querySelector('[data-action="delete-channel"]')?.addEventListener('click', e => deleteChannel(e.currentTarget.dataset.channelId, e.currentTarget.dataset.channelName));
        }

        async function updateUserRole(userId, newRole) {
            const profilePath = `artifacts/${sanitizedAppId}/public/data/profiles/${userId}`;
            const setDocFn = USE_MOCK_FIRESTORE ? mockFirestore.setDoc : setDoc;
            const profileRef = USE_MOCK_FIRESTORE ? profilePath : doc(db, profilePath);
            try {
                await setDocFn(profileRef, { role: newRole }, { merge: true });
            } catch (error) { console.error(`Failed to update role for ${userId}:`, error); }
        }

        async function kickUser(userId) {
            if (!currentChatRoomId) return;
            const messagesPath = `artifacts/${sanitizedAppId}/public/data/chatrooms/${currentChatRoomId}/messages`;
            const deleteDocFn = USE_MOCK_FIRESTORE ? mockFirestore.deleteDoc : deleteDoc;
            const allMessages = getCollectionDocs(messagesPath);
            const userMessages = allMessages.filter(msg => msg.data().senderId === userId);
            try {
                for (const msg of userMessages) {
                    await deleteDocFn(`${messagesPath}/${msg.id}`);
                }
            } catch (error) { console.error(`Failed to kick user ${userId}:`, error); }
        }

        async function timeoutUser(userId) {
            const durationMinutes = prompt("Enter timeout duration in minutes:", "5");
            if (durationMinutes === null || isNaN(durationMinutes) || durationMinutes <= 0) {
                return;
            }
            const timeoutUntil = new Date(Date.now() + durationMinutes * 60 * 1000).toISOString();
            const profilePath = `artifacts/${sanitizedAppId}/public/data/profiles/${userId}`;
            const setDocFn = USE_MOCK_FIRESTORE ? mockFirestore.setDoc : setDoc;
            const profileRef = USE_MOCK_FIRESTORE ? profilePath : doc(db, profilePath);
            try {
                await setDocFn(profileRef, { timeoutUntil: timeoutUntil }, { merge: true });
            } catch (error) {
                console.error(`Failed to timeout user ${userId}:`, error);
            }
        }

        function checkAndUpdateTimeoutState() {
            if (timeoutInterval) clearInterval(timeoutInterval);

            const update = () => {
                if (!currentUserProfile || !currentUserProfile.timeoutUntil) {
                    mainChatInput.disabled = false;
                    mainChatInput.placeholder = "Type a message...";
                    clearInterval(timeoutInterval);
                    return;
                }

                const timeoutEndDate = new Date(currentUserProfile.timeoutUntil);
                const now = new Date();
                const remainingSeconds = Math.round((timeoutEndDate - now) / 1000);

                if (remainingSeconds > 0) {
                    mainChatInput.disabled = true;
                    const minutes = Math.floor(remainingSeconds / 60);
                    const seconds = remainingSeconds % 60;
                    mainChatInput.placeholder = `You are in timeout for ${minutes}:${seconds.toString().padStart(2, '0')}`;
                } else {
                    mainChatInput.disabled = false;
                    mainChatInput.placeholder = "Type a message...";
                    delete currentUserProfile.timeoutUntil;
                    clearInterval(timeoutInterval);
                }
            };

            update();
            timeoutInterval = setInterval(update, 1000);
        }

        const availableEmotes = ['☘️', '🌸', '🍓', '🍄', '✨', '🌙', '🪐', '🦊', '🐸', '🐢', '🦋', '⭐'];

        async function updateProfilePic(newEmote) {
            if (!currentUserId) return;
            const profilePath = `artifacts/${sanitizedAppId}/public/data/profiles/${currentUserId}`;
            const setDocFn = USE_MOCK_FIRESTORE ? mockFirestore.setDoc : setDoc;
            const profileRef = USE_MOCK_FIRESTORE ? profilePath : doc(db, profilePath);
            try {
                await setDocFn(profileRef, { profilePic: newEmote }, { merge: true });
                updateUserUI(currentUserAnonymousName, newEmote);
                if (userProfilesCache[currentUserId]) userProfilesCache[currentUserId].profilePic = newEmote;
                if (currentUserProfile) currentUserProfile.profilePic = newEmote;
            } catch (error) { console.error("Error updating profile picture:", error); }
        }

        function initializeProfilePic() {
            [dashboardProfilePicContainer, document.getElementById('chat-profile-pic-container')].forEach(el => {
                el.addEventListener('click', () => emotePickerModal.classList.remove('hidden'));
            });
            closeEmoteModalBtn.addEventListener('click', () => emotePickerModal.classList.add('hidden'));
            emotePickerModal.addEventListener('click', (e) => {
                if (e.target === emotePickerModal) emotePickerModal.classList.add('hidden');
            });
            emoteGrid.addEventListener('click', (e) => {
                if (e.target.tagName === 'BUTTON') {
                    const newEmote = e.target.textContent;
                    updateProfilePic(newEmote);
                    emotePickerModal.classList.add('hidden');
                }
            });
        }

        function populateEmotePicker() {
            emoteGrid.innerHTML = availableEmotes.map(emote =>
                `<button class="p-2 rounded-lg hover:bg-white/10 transition-colors">${emote}</button>`
            ).join('');
        }

        function initializeMediaSending() {
            const attachmentBtn = document.getElementById('attachment-btn');
            const attachmentMenu = document.getElementById('attachment-menu');
            const attachImageBtn = document.getElementById('attach-image-btn');
            const attachDocBtn = document.getElementById('attach-doc-btn');
            const recordVoiceBtn = document.getElementById('record-voice-btn');
            const imageUploadInput = document.getElementById('image-upload-input');
            const docUploadInput = document.getElementById('doc-upload-input');
            const imagePreviewModal = document.getElementById('image-preview-modal');
            const previewImage = document.getElementById('preview-image');
            const imageCaptionInput = document.getElementById('image-caption-input');
            const sendImageBtn = document.getElementById('send-image-btn');
            const cancelImageBtn = document.getElementById('cancel-image-btn');
            const voiceRecorderContainer = document.getElementById('voice-recorder-container');

            let imageFile = null;
            let mediaRecorder = null;
            let audioChunks = [];

            attachmentBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const isHidden = attachmentMenu.classList.contains('hidden');
                if (isHidden) {
                    attachmentMenu.classList.remove('hidden');
                    setTimeout(() => {
                        attachmentMenu.classList.remove('scale-90', 'opacity-0');
                        attachmentBtn.style.transform = 'rotate(45deg)';
                    }, 10);
                } else {
                    attachmentMenu.classList.add('scale-90', 'opacity-0');
                    attachmentBtn.style.transform = 'rotate(0deg)';
                    setTimeout(() => attachmentMenu.classList.add('hidden'), 200);
                }
            });
            document.addEventListener('click', () => {
                if (!attachmentMenu.classList.contains('hidden')) {
                    attachmentMenu.classList.add('scale-90', 'opacity-0');
                    attachmentBtn.style.transform = 'rotate(0deg)';
                    setTimeout(() => attachmentMenu.classList.add('hidden'), 200);
                }
            });

            attachImageBtn.addEventListener('click', () => imageUploadInput.click());
            attachDocBtn.addEventListener('click', () => docUploadInput.click());

            imageUploadInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    imageFile = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        previewImage.src = event.target.result;
                        imagePreviewModal.style.display = 'flex';
                    }
                    reader.readAsDataURL(imageFile);
                }
            });

            cancelImageBtn.addEventListener('click', () => {
                imagePreviewModal.style.display = 'none';
                imageCaptionInput.value = '';
                imageUploadInput.value = '';
                imageFile = null;
            });

            sendImageBtn.addEventListener('click', () => {
                if (!imageFile) return;
                const caption = imageCaptionInput.value.trim();
                sendMessage({ type: 'image', content: previewImage.src, caption: caption });
                cancelImageBtn.click();
            });

            docUploadInput.addEventListener('change', e => {
                if (e.target.files && e.target.files[0]) {
                    const docFile = e.target.files[0];
                    sendMessage({ type: 'document', fileName: docFile.name });
                    docUploadInput.value = '';
                }
            });

            recordVoiceBtn.addEventListener('click', async () => {

                // --- ADD THESE 4 LINES ---
                // Force-hide the emoji panel in case it's invisibly open
                const emojiPanel = document.getElementById('emoji-panel');
                emojiPanel.classList.add('scale-90', 'opacity-0');
                emojiPanel.classList.add('hidden'); // 'hidden' is (display: none)
                // --- END OF ADDED CODE ---
                if (mediaRecorder && mediaRecorder.state === "recording") {
                    mediaRecorder.stop();
                    return;
                }
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    let options = {};
                    try {
                        if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
                            options.mimeType = 'audio/webm;codecs=opus';
                        } else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/webm')) {
                            options.mimeType = 'audio/webm';
                        } else if (MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported('audio/ogg;codecs=opus')) {
                            options.mimeType = 'audio/ogg;codecs=opus';
                        } else {
                            options.mimeType = 'audio/webm'; // best-effort fallback
                        }
                    } catch (err) {
                        options = {};
                    }
                    try {
                        mediaRecorder = new MediaRecorder(stream, options);
                    } catch (err) {
                        // Some browsers will throw if options.mimeType not supported; fallback to default:
                        console.warn('MediaRecorder creation with options failed, using default. Error:', err);
                        mediaRecorder = new MediaRecorder(stream);
                    }

                    audioChunks = [];
                    mediaRecorder.addEventListener("dataavailable", event => { audioChunks.push(event.data); });
                    mediaRecorder.addEventListener("stop", () => {
                        console.log('mediaRecorder.stop -> audioChunks length:', audioChunks.length);
                        // Use recorded mimeType when available
                        const blobType = (mediaRecorder && mediaRecorder.mimeType) ? mediaRecorder.mimeType : 'audio/webm';
                        const audioBlob = new Blob(audioChunks, { type: blobType });
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const dataUrl = event.target.result;
                            console.log('Recorder -> dataUrl length:', dataUrl ? dataUrl.length : 'NO_DATA', 'startsWith data:', dataUrl ? dataUrl.slice(0, 50) : '');
                            sendMessage({ type: 'audio', content: dataUrl });
                        };
                        reader.readAsDataURL(audioBlob);
                        voiceRecorderContainer.innerHTML = '';
                    });


                    startRecordingUI();
                    mediaRecorder.start();
                } catch (err) {
                    console.error("Error accessing microphone:", err);
                    alert("Could not access microphone. Please ensure permissions are granted.");
                }
            });

            function startRecordingUI() {
                let seconds = 0;
                let interval;

                // 1. Clear the container
                voiceRecorderContainer.innerHTML = '';

                // 2. Create all elements manually
                const recorderDiv = document.createElement('div');
                recorderDiv.id = 'voice-recorder';
                recorderDiv.className = 'glass p-2 rounded-lg flex items-center justify-between mb-2';

                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex items-center gap-2';

                const micIcon = document.createElement('i');
                micIcon.setAttribute('data-lucide', 'mic');
                micIcon.className = 'w-5 h-5 text-red-500 animate-pulse';

                const timerSpan = document.createElement('span');
                timerSpan.id = 'recorder-timer';
                timerSpan.className = 'font-mono';
                timerSpan.textContent = '00:00';

                infoDiv.appendChild(micIcon);
                infoDiv.appendChild(timerSpan);

                const stopButton = document.createElement('button');
                stopButton.id = 'stop-recording-btn';
                stopButton.className = 'bg-red-500 text-white rounded-full p-2';

                const stopIcon = document.createElement('i');
                stopIcon.setAttribute('data-lucide', 'stop-circle');
                stopIcon.className = 'w-5 h-5';

                stopButton.appendChild(stopIcon);

                recorderDiv.appendChild(infoDiv);
                recorderDiv.appendChild(stopButton);

                // 3. This listener handles the click, stops propagation,
                //    stops the timer, removes the UI, and stops the recorder.
                stopButton.addEventListener('click', (e) => {
                    e.stopPropagation(); // Stops the click from bubbling

                    clearInterval(interval); // Stop the visual timer

                    voiceRecorderContainer.innerHTML = ''; // IMMEDIATELY remove the UI

                    if (mediaRecorder && mediaRecorder.state === "recording") {
                        mediaRecorder.stop(); // Stop the actual recording
                    }
                });

                // 4. Now, add the new UI to the page
                voiceRecorderContainer.appendChild(recorderDiv);

                // 5. Render the icons
                lucide.createIcons({ nodes: [voiceRecorderContainer] });

                // 6. Start the timer interval
                interval = setInterval(() => {
                    seconds++;
                    const minutes = Math.floor(seconds / 60).toString().padStart(2, '0');
                    const secs = (seconds % 60).toString().padStart(2, '0');
                    timerSpan.textContent = `${minutes}:${secs}`;
                }, 1000);
            }
        }

        function initializeChannelManagement() {
            channelButtonsContainer.addEventListener('contextmenu', e => showChannelContextMenu(e));
        }

        async function addChannel() {
            const name = prompt("Enter new channel name:");
            if (!name || name.trim() === '') return;
            const id = name.trim().toLowerCase().replace(/\s+/g, '-');
            const channelPath = `artifacts/${sanitizedAppId}/public/data/channels/${id}`;
            try {
                // Correctly use the live setDoc function with the doc helper from the Firebase SDK
                await setDoc(doc(db, channelPath), { name: name.trim(), id, icon: 'hash' });
            } catch (error) { console.error("Error adding channel:", error); }
        }

        async function deleteChannel(channelId, channelName) {
            if (!confirm(`Are you sure you want to delete the channel #${channelName}? This cannot be undone.`)) return;
            const channelPath = `artifacts/${sanitizedAppId}/public/data/channels/${channelId}`;
            try {
                await mockFirestore.deleteDoc(channelPath);
            } catch (error) { console.error("Error deleting channel:", error); }
        }

        function listenToChannels() {
            if (unsubscribeFromChannels) unsubscribeFromChannels();
            const channelsPath = `artifacts/${sanitizedAppId}/public/data/channels`;
            const onSnapshotFn = USE_MOCK_FIRESTORE ? mockFirestore.onSnapshot : onSnapshot;
            const collectionRef = USE_MOCK_FIRESTORE ? channelsPath : collection(db, channelsPath);

            unsubscribeFromChannels = onSnapshotFn(collectionRef, (snapshot) => {
                const channels = snapshot.docs.map(doc => doc.data());
                renderChannelList(channels);
            });
        }

        function renderChannelList(channels) {
            channelButtonsContainer.innerHTML = `
                <button class="channel-btn w-full text-left p-3 transition-colors flex items-center gap-3" data-room-name="Notices" data-channel-id="notices">
                    <i data-lucide="megaphone" class="w-5 h-5"></i> Notices
                </button>
            `;
            channels.forEach(channel => {
                const btn = document.createElement('button');
                btn.className = "channel-btn w-full text-left p-3 transition-colors flex items-center gap-3";
                btn.dataset.roomName = channel.name;
                btn.dataset.channelId = channel.id;
                btn.innerHTML = `<i data-lucide="${channel.icon || 'hash'}" class="w-5 h-5"></i> ${channel.name}`;
                channelButtonsContainer.appendChild(btn);
            });

            lucide.createIcons({ nodes: [channelButtonsContainer] });

            // START OF CHANGE: Event delegation for channels
            channelButtonsContainer.addEventListener('click', (e) => {
                const target = e.target.closest('.channel-btn');
                if (target) {
                    document.querySelectorAll('.channel-btn').forEach(b => b.classList.remove('active'));
                    target.classList.add('active');
                    joinChatRoom(target.dataset.channelId, target.dataset.roomName);
                }
            });
            // END OF CHANGE
        }

        function initializeEmojiPanel() {
            const emojiBtn = document.getElementById('emoji-btn');
            const emojiPanel = document.getElementById('emoji-panel');
            const emojisGrid = document.getElementById('emojis-grid');
            const stickersGrid = document.getElementById('stickers-grid');
            const emojiTabs = emojiPanel.querySelectorAll('.emoji-tab');

            const emojis = ['😀', '😃', '😄', '😁', '😆', '😅', '😂', '🤣', '😊', '😇', '🙂', '🙃', '😉', '😌', '😍', '🥰', '😘', '😗', '😙', '😚', '😋', '😛', '😝', '😜', '🤪', '🤨', '🧐', '🤓', '😎', '🤩', '🥳', '😏', '😒', '😞', '😔', '😟', '😕', '🙁', '☹️', '😣', '😖', '😫', '😩', '🥺', '😢', '😭', '😤', '😠', '😡', '🤬', '🤯', '😳', '🥵', '🥶', '😱', '😨', '😰', '😥', '😓', '🤗', '🤔', '🤭', '🤫', '🤥', '😶', '😐', '😑', '😬', '🙄', '😯', '😦', '😧', '😮', '😲', '🥱', '😴', '🤤', '😪', '😵', '🤐', '🥴', '🤢', '🤮', '🤧', '😷', '🤒', '🤕', '🤑', '🤠', '😈', '👿', '👹', '👺', '🤡', '💩', '👻', '💀', '☠️', '👽', '👾', '🤖', '🎃'];
            const stickers = ['👍', '❤️', '😂', '🙏', '🔥', '🎉', '💯', '👋'];

            emojisGrid.innerHTML = emojis.map(e => `<button class="emoji-btn">${e}</button>`).join('');
            stickersGrid.innerHTML = stickers.map(s => `<button class="sticker-btn">${s}</button>`).join('');

            emojiBtn.addEventListener('click', e => {
                e.stopPropagation();
                const isHidden = emojiPanel.classList.contains('hidden');
                if (isHidden) {
                    emojiPanel.classList.remove('hidden');
                    setTimeout(() => emojiPanel.classList.remove('scale-90', 'opacity-0'), 10);
                } else {
                    emojiPanel.classList.add('scale-90', 'opacity-0');
                    setTimeout(() => emojiPanel.classList.add('hidden'), 200);
                }
            });

            document.addEventListener('click', (e) => {
                if (!emojiPanel.classList.contains('hidden') && !emojiPanel.contains(e.target) && e.target !== emojiBtn) {
                    emojiPanel.classList.add('scale-90', 'opacity-0');
                    setTimeout(() => emojiPanel.classList.add('hidden'), 200);
                }
            });

            emojiTabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    emojiTabs.forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    if (tab.dataset.tab === 'emojis') {
                        emojisGrid.classList.remove('hidden');
                        stickersGrid.classList.add('hidden');
                    } else {
                        emojisGrid.classList.add('hidden');
                        stickersGrid.classList.remove('hidden');
                    }
                });
            });

            emojiPanel.addEventListener('click', e => {
                if (e.target.matches('.emoji-btn')) {
                    mainChatInput.value += e.target.textContent;
                    mainChatInput.focus();
                }
                if (e.target.matches('.sticker-btn')) {
                    sendMessage({ type: 'sticker', content: e.target.textContent });
                    emojiPanel.classList.add('scale-90', 'opacity-0');
                    setTimeout(() => emojiPanel.classList.add('hidden'), 200);
                }
            });
        }




        // --- AI Chatbot with Personalities Logic ---
        let aiChatHistory = [];

        async function getGeminiResponseWithPersonality(prompt, history, personality) {
            const personalityPrompts = {
                helpful: "You are a helpful and friendly assistant named blossom AI. You are concise and to the point. You will act as a companion, a close friend, always chat like a good friend and help the user take out their emotions, help them feel light and vent",
                creative: "You are a creative muse named blossom AI. You think outside the box and provide imaginative and inspiring ideas. You speak in a poetic and slightly eccentric way. ",
                sarcastic: "You are a sarcastic, witty bot named blossom AI. You answer questions correctly but with a dry sense of humor and a bit of sass. You're not mean, just amusingly unimpressed. "
            };

            const systemPrompt = personalityPrompts[personality] || personalityPrompts['helpful'];

            const contents = history.map(msg => ({
                role: msg.sender === 'user' ? 'user' : 'model',
                parts: [{ text: msg.text }]
            }));
            contents.push({ role: 'user', parts: [{ text: prompt }] });

            try {
                const payload = {
                    contents: contents,
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                };
                const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => null);
                    const errorMessage = errorData?.error?.message || response.statusText;
                    throw new Error(`API error (${response.status}): ${errorMessage}`);
                }
                const result = await response.json();
                return result.candidates?.[0]?.content?.parts?.[0]?.text || "I'm not sure how to respond to that.";
            } catch (error) {
                console.error("Error calling Gemini API:", error);
                return `Sorry, I'm having trouble connecting right now. Error: ${error.message}`;
            }
        }

        function displayAiChatMessage(text, sender, save = true) {
            const messageContainer = document.createElement('div');
            messageContainer.className = `chat-message ${sender}`;
            const bubble = document.createElement('div');
            bubble.className = `chat-bubble ${sender}`;
            bubble.textContent = text;
            messageContainer.appendChild(bubble);
            aiChatMessages.appendChild(messageContainer);
            aiChatMessages.scrollTop = aiChatMessages.scrollHeight;

            if (save) {
                aiChatHistory.push({ sender, text });
                localStorage.setItem('aiChatHistory', JSON.stringify(aiChatHistory));
            }
        }

        async function handleAiSendMessage() {
            const userInput = aiChatInput.value.trim();
            if (!userInput) return;

            aiChatSendBtn.disabled = true;
            aiChatInput.value = '';
            displayAiChatMessage(userInput, 'user');

            const typingIndicator = document.createElement('div');
            typingIndicator.id = 'ai-typing-indicator';
            typingIndicator.className = 'chat-message ai';
            typingIndicator.innerHTML = `<div class="chat-bubble ai"><div class="loader" style="width:20px; height:20px; margin:0;"></div></div>`;
            aiChatMessages.appendChild(typingIndicator);
            aiChatMessages.scrollTop = aiChatMessages.scrollHeight;

            try {
                await checkForSuicidalIntent(userInput);

                const personality = aiPersonalitySelector.value;
                const aiResponse = await getGeminiResponseWithPersonality(userInput, aiChatHistory, personality);

                document.getElementById('ai-typing-indicator').remove();
                displayAiChatMessage(aiResponse, 'ai');
            } catch (error) {
                console.error("Error sending AI message or flagging content:", error);
                showNotification("Your message could not be processed due to a safety check error.", "error");
                document.getElementById('ai-typing-indicator')?.remove();
            } finally {
                aiChatSendBtn.disabled = false;
            }
        }

        function loadAiChatHistory() {
            const savedHistory = localStorage.getItem('aiChatHistory');
            if (savedHistory && JSON.parse(savedHistory).length > 0) {
                aiChatHistory = JSON.parse(savedHistory);
                aiChatMessages.innerHTML = '';
                aiChatHistory.forEach(msg => displayAiChatMessage(msg.text, msg.sender, false));
            } else {
                aiChatHistory = [];
                displayAiChatMessage("Hello! I'm blossom AI. How can I help you bloom today?", 'ai', false);
            }
        }

        function initializeAiChat() {
            aiChatToggleBtn.addEventListener('click', () => {
                aiChatWindow.classList.toggle('hidden');
                chatWindow.classList.add('hidden'); // Hide peer chat if open
                lucide.createIcons();
            });
            aiChatCloseBtn.addEventListener('click', () => aiChatWindow.classList.add('hidden'));
            aiChatSendBtn.addEventListener('click', handleAiSendMessage);
            aiChatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleAiSendMessage();
            });

            aiChatClearBtn.addEventListener('click', () => {
                aiChatHistory = [];
                localStorage.removeItem('aiChatHistory');
                aiChatMessages.innerHTML = '';
                displayAiChatMessage("Hello! I'm blossom AI. How can I help you bloom today?", 'ai', false);
            });
        }

        // --- Profile Picture Logic ---
        const profilePicContainer = document.getElementById('profile-pic-container');
        const profilePicEmoji = document.getElementById('profile-pic-emoji');
        const emotePickerModal = document.getElementById('emote-picker-modal');
        const closeEmoteModalBtn = document.getElementById('close-emote-modal');
        const emoteGrid = document.getElementById('emote-grid');

        function loadProfilePic() {
            const savedEmote = localStorage.getItem('dashboardProfilePic');
            if (savedEmote) profilePicEmoji.textContent = savedEmote;
        }

        // --- Music Player Helper Functions ---
        function generateCodeVerifier(length) {
            let text = '';
            let possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }

        async function generateCodeChallenge(codeVerifier) {
            const data = new TextEncoder().encode(codeVerifier);
            const digest = await window.crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode.apply(null, [...new Uint8Array(digest)]))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=+$/, '');
        }

        // --- Assignments Logic (Fixed) ---
        let assignmentStorageMode = localStorage.getItem('assignmentStorageMode') || 'server';
        let unsubscribeFromAssignments = null;

        function clearAssignmentsList() {
            while (assignmentsList.children.length > 1) {
                assignmentsList.removeChild(assignmentsList.lastChild);
            }
        }

        function renderAssignment(data, id) {
            const item = document.createElement('div');
            item.className = `task-item grid grid-cols-[auto,1fr,auto,auto,auto] gap-x-4 items-center ${data.completed ? 'completed' : ''}`;
            item.dataset.id = id;

            item.innerHTML = `
                <input type="checkbox" class="task-checkbox" ${data.completed ? 'checked' : ''}>
                <span>${data.name}</span>
                <span class="course-tag" style="background-color: ${getCourseColor(data.course)}">${data.course || 'General'}</span>
                <span>${data.dueDate ? new Date(data.dueDate).toLocaleDateString() : 'No date'}</span>
                <button class="delete-assignment-btn text-gray-500 hover:text-red-400"><i data-lucide="trash-2" class="w-4 h-4"></i></button>
            `;

            assignmentsList.appendChild(item);
            lucide.createIcons();
        }

        function getCourseColor(course) {
            let hash = 0;
            for (let i = 0; i < (course || '').length; i++) {
                hash = course.charCodeAt(i) + ((hash << 5) - hash);
            }
            const color = `hsl(${hash % 360}, 50%, 60%)`;
            return color;
        }

        function initializeAssignments() {
            clearAssignmentsList();
            if (unsubscribeFromAssignments) {
                unsubscribeFromAssignments();
                unsubscribeFromAssignments = null;
            }

            const syncAssignmentsBtn = document.getElementById('sync-assignments-btn');
            if (assignmentStorageMode === 'server') {
                initializeFirestoreAssignments();
                syncAssignmentsBtn.classList.add('hidden');
            } else {
                initializeLocalAssignments();
                syncAssignmentsBtn.classList.remove('hidden');
            }
            storageToggle.checked = assignmentStorageMode === 'server';
        }

        function initializeFirestoreAssignments() {
            const user = auth.currentUser;

            if (!user) {
                clearAssignmentsList();
                const infoItem = document.createElement('div');
                infoItem.className = 'text-center text-gray-400 p-4 col-span-full';
                infoItem.textContent = 'Connecting to server...';
                assignmentsList.appendChild(infoItem);
                return;
            }

            const assignmentsRef = collection(db, `artifacts/${sanitizedAppId}/users/${user.uid}/assignments`);
            const q = query(assignmentsRef);

            unsubscribeFromAssignments = onSnapshot(q, (snapshot) => {
                clearAssignmentsList();
                const assignments = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                assignments.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
                assignments.forEach(assignment => {
                    renderAssignment(assignment, assignment.id);
                });
            }, (error) => {
                console.error("Error getting assignments:", error);
                clearAssignmentsList();
                const errorItem = document.createElement('div');
                errorItem.className = 'text-center text-red-400 p-4 col-span-full';
                errorItem.textContent = 'Error: Could not load assignments. Check Firestore rules.';
                assignmentsList.appendChild(errorItem);
            });
        }

        function initializeLocalAssignments() {
            const localTasks = JSON.parse(localStorage.getItem('localAssignments')) || [];
            clearAssignmentsList();
            localTasks.forEach(task => renderAssignment(task, task.id));
        }

        function setupAssignmentEventListeners() {
            storageToggle.addEventListener('change', () => {
                assignmentStorageMode = storageToggle.checked ? 'server' : 'local';
                localStorage.setItem('assignmentStorageMode', assignmentStorageMode);
                initializeAssignments();
            });

            newAssignmentBtn.addEventListener('click', () => {
                newAssignmentForm.classList.remove('hidden');
                newAssignmentBtn.classList.add('hidden');
            });

            cancelAssignmentBtn.addEventListener('click', () => {
                newAssignmentForm.classList.add('hidden');
                newAssignmentBtn.classList.remove('hidden');
                newAssignmentForm.reset();
            });

            newAssignmentForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const name = document.getElementById('new-assignment-name').value.trim();
                const course = document.getElementById('new-assignment-course').value.trim();
                const dueDate = document.getElementById('new-assignment-due-date').value;

                if (!name) return;

                if (assignmentStorageMode === 'server') {
                    if (!db || !currentUserId) {
                        showNotification("Cannot save to server. Connection not ready, please wait a moment.", "error");
                        return;
                    }
                    await addDoc(collection(db, `artifacts/${sanitizedAppId}/users/${currentUserId}/assignments`), {
                        name, course, dueDate, completed: false, createdAt: serverTimestamp()
                    });
                } else {
                    const localTasks = JSON.parse(localStorage.getItem('localAssignments')) || [];
                    const newTask = {
                        id: Date.now().toString(), name, course, dueDate, completed: false, createdAt: new Date().toISOString()
                    };
                    localTasks.push(newTask);
                    localStorage.setItem('localAssignments', JSON.stringify(localTasks));
                    initializeLocalAssignments();
                }

                newAssignmentForm.reset();
                newAssignmentForm.classList.add('hidden');
                newAssignmentBtn.classList.remove('hidden');
            });

            assignmentsList.addEventListener('click', async (e) => {
                const target = e.target;
                const taskItem = target.closest('.task-item');
                if (!taskItem) return;
                const id = taskItem.dataset.id;

                if (assignmentStorageMode === 'server') {
                    if (!db || !currentUserId) return;
                    const docRef = doc(db, `artifacts/${sanitizedAppId}/users/${currentUserId}/assignments`, id);
                    if (target.matches('.task-checkbox')) {
                        await updateDoc(docRef, { completed: target.checked });
                    }
                    if (target.closest('.delete-assignment-btn')) {
                        await deleteDoc(docRef);
                    }
                } else {
                    let localTasks = JSON.parse(localStorage.getItem('localAssignments')) || [];
                    if (target.matches('.task-checkbox')) {
                        const taskIndex = localTasks.findIndex(t => t.id === id);
                        if (taskIndex > -1) {
                            localTasks[taskIndex].completed = target.checked;
                        }
                    }
                    if (target.closest('.delete-assignment-btn')) {
                        localTasks = localTasks.filter(t => t.id !== id);
                    }
                    localStorage.setItem('localAssignments', JSON.stringify(localTasks));
                    initializeLocalAssignments();
                }
            });

            document.getElementById('sync-assignments-btn').addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) {
                    showNotification("Please wait for connection to sync.", "error");
                    return;
                }

                const syncBtn = document.getElementById('sync-assignments-btn');
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';

                const localTasks = JSON.parse(localStorage.getItem('localAssignments')) || [];
                if (localTasks.length === 0) {
                    showNotification("No local assignments to sync.");
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync to Server';
                    return;
                }

                try {
                    const assignmentsRef = collection(db, `artifacts/${sanitizedAppId}/users/${user.uid}/assignments`);
                    for (const task of localTasks) {
                        const serverTask = {
                            name: task.name,
                            course: task.course,
                            dueDate: task.dueDate,
                            completed: task.completed,
                            createdAt: serverTimestamp()
                        };
                        await addDoc(assignmentsRef, serverTask);
                    }

                    localStorage.removeItem('localAssignments');
                    assignmentStorageMode = 'server';
                    localStorage.setItem('assignmentStorageMode', assignmentStorageMode);
                    initializeAssignments();
                    showNotification("Local assignments synced successfully and storage switched to server mode.");

                } catch (error) {
                    console.error("Error syncing assignments:", error);
                    showNotification("An error occurred during sync. Please try again.", "error");
                } finally {
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync to Server';
                }
            });
        }


        // --- User Health Logic (Final Fix) ---
        const healthStatsContainer = document.getElementById('health-stats-container');
        const googleFitAuthContainer = document.getElementById('google-fit-auth-container');
        let fitTokenClient;
        let isFetchingFitData = false; // Flag to prevent re-entrant calls

        function renderHealthGauge(id, label, value, goal) {
            const container = document.createElement('div');
            container.className = 'flex flex-col items-center';

            const percent = Math.min((value / goal) * 100, 100);
            const angle = (percent / 100) * 180 - 90; // -90 to 90 degrees

            const gaugeHTML = `
                <div class="health-gauge">
                    <div class="gauge-arc">
                        <div class="gauge-arc-segments">
                            <div class="gauge-arc-mask"></div>
                        </div>
                    </div>
                    <div class="gauge-needle-container" style="--needle-angle: ${angle}deg;">
                        <div class="gauge-needle"></div>
                    </div>
                </div>
                <div class="gauge-text">
                    <span class="gauge-value">${value.toLocaleString()}</span>
                    <span class="gauge-label">${label}</span>
                </div>
            `;
            container.innerHTML = gaugeHTML;
            return container;
        }

        function displayDummyHealthData() {
            healthStatsContainer.innerHTML = ''; // Clear previous
            healthStatsContainer.appendChild(renderHealthGauge('steps', 'Steps', 0, 10000));
            healthStatsContainer.appendChild(renderHealthGauge('move', 'Move Mins', 0, 60));
            healthStatsContainer.appendChild(renderHealthGauge('heart', 'Heart Pts', 0, 25));
        }

        async function fetchGoogleFitData(accessToken) {
            if (isFetchingFitData) {
                console.warn("Fetch already in progress. Aborting.");
                return;
            }
            isFetchingFitData = true;

            const FIT_API_URL = 'https://www.googleapis.com/fitness/v1/users/me/dataset:aggregate';
            const now = new Date();
            const startTime = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
            const endTime = new Date();

            const requestBody = {
                aggregateBy: [{
                    dataTypeName: "com.google.step_count.delta"
                }, {
                    dataTypeName: "com.google.active_minutes"
                }, {
                    dataTypeName: "com.google.heart_minutes"
                }],
                bucketByTime: { durationMillis: 86400000 },
                startTimeMillis: startTime.getTime(),
                endTimeMillis: endTime.getTime()
            };

            try {
                const response = await fetch(FIT_API_URL, {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${accessToken}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        localStorage.removeItem('googleFitToken');
                    }
                    throw new Error(`Google Fit API error: ${response.statusText}`);
                }
                const data = await response.json();
                healthStatsContainer.innerHTML = '';

                const stepBucket = data.bucket[0]?.dataset[0]?.point[0];
                const steps = stepBucket?.value[0]?.intVal || 0;
                healthStatsContainer.appendChild(renderHealthGauge('steps', 'Steps', steps, 10000));

                const moveMinutesBucket = data.bucket[0]?.dataset[1]?.point[0];
                const moveMinutes = moveMinutesBucket?.value[0]?.intVal || 0;
                healthStatsContainer.appendChild(renderHealthGauge('move', 'Move Mins', moveMinutes, 60));

                const heartPointsBucket = data.bucket[0]?.dataset[2]?.point[0];
                const heartPoints = Math.round(heartPointsBucket?.value[0]?.fpVal || 0);
                healthStatsContainer.appendChild(renderHealthGauge('heart', 'Heart Pts', heartPoints, 25));

                googleFitAuthContainer.innerHTML = `<p class="text-sm text-green-400">Synced just now.</p>`;
            } catch (error) {
                console.error("Failed to fetch Google Fit data:", error);
                displayDummyHealthData();
                googleFitAuthContainer.innerHTML = `<p class="text-sm text-red-400">Sync failed. Please reconnect.</p>
                    <button id="google-fit-login-btn" class="mt-2 bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Reconnect</button>`;
                document.getElementById('google-fit-login-btn').addEventListener('click', handleFitLogin);
            } finally {
                isFetchingFitData = false;
            }
        }

        function initializeHealthWidget() {
            const fitToken = localStorage.getItem('googleFitToken');

            if (fitToken && !isFetchingFitData) {
                googleFitAuthContainer.innerHTML = `<p class="text-sm text-green-400">Syncing Google Fit...</p>`;
                fetchGoogleFitData(fitToken);
            } else if (!fitToken) {
                displayDummyHealthData();
                if (GOOGLE_FIT_CLIENT_ID.includes('YOUR_')) {
                    googleFitAuthContainer.innerHTML = `<p class="text-sm text-gray-400">Add Google Fit Client ID in code to connect.</p>`;
                } else {
                    googleFitAuthContainer.innerHTML = `<button id="google-fit-login-btn" class="bg-blue-500 text-white px-4 py-2 rounded hover:bg-blue-600">Connect Google Fit</button>`;
                    document.getElementById('google-fit-login-btn').addEventListener('click', handleFitLogin);
                }
            }
        }

        function handleFitLogin() {
            if (typeof google === 'undefined' || !google.accounts) {
                showNotification("Google scripts not loaded yet. Please try again.", "error"); return;
            }
            try {
                fitTokenClient = google.accounts.oauth2.initTokenClient({
                    client_id: GOOGLE_FIT_CLIENT_ID,
                    scope: 'https://www.googleapis.com/auth/fitness.activity.read',
                    callback: handleFitAuthResponse,
                });
                fitTokenClient.requestAccessToken({ prompt: 'consent' });
            } catch (e) {
                console.error("GSI Init Failed for Google Fit. Check Client ID.", e);
                googleFitAuthContainer.innerHTML = `<p class="text-sm text-red-400">Error: Check Google Fit Client ID.</p>`;
            }
        }

        async function handleFitAuthResponse(tokenResponse) {
            if (tokenResponse.access_token) {
                localStorage.setItem('googleFitToken', tokenResponse.access_token);
                initializeHealthWidget();
            } else {
                googleFitAuthContainer.innerHTML = `<p class="text-sm text-red-400">Failed to connect Google Fit.</p>`;
            }
        }

        // --- Journaling Logic ---
        const shadowWorkPromptBtn = document.getElementById('shadow-work-prompt-btn');
        const journalEntryTextarea = document.getElementById('journal-entry');
        const saveJournalEntryBtn = document.getElementById('save-journal-entry-btn');
        const journalHistoryList = document.getElementById('journal-history-list');
        const journalStorageToggle = document.getElementById('journal-storage-toggle');
        const journalAnalysisModal = document.getElementById('journal-analysis-modal');
        const closeJournalAnalysisModal = document.getElementById('close-journal-analysis-modal');
        const journalAnalysisContent = document.getElementById('journal-analysis-content');

        let journalStorageMode = localStorage.getItem('journalStorageMode') || 'server';
        let unsubscribeFromJournal = null;

        function initializeJournaling() {
            if (unsubscribeFromJournal) unsubscribeFromJournal();
            journalHistoryList.innerHTML = '';

            const syncJournalBtn = document.getElementById('sync-journal-btn');
            if (journalStorageMode === 'server') {
                initializeFirestoreJournal();
                syncJournalBtn.classList.add('hidden');
            } else {
                initializeLocalJournal();
                syncJournalBtn.classList.remove('hidden');
            }
            journalStorageToggle.checked = journalStorageMode === 'server';
        }

        function initializeFirestoreJournal() {
            const user = auth.currentUser;
            if (!user) {
                journalHistoryList.innerHTML = '<p class="text-sm text-center text-gray-400">Connecting to server...</p>';
                return;
            }
            const journalRef = collection(db, `artifacts/${sanitizedAppId}/users/${user.uid}/journal`);
            const q = query(journalRef);
            unsubscribeFromJournal = onSnapshot(q, snapshot => {
                journalHistoryList.innerHTML = '';
                const entries = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                entries.sort((a, b) => (b.createdAt?.seconds || 0) - (a.createdAt?.seconds || 0));
                entries.forEach(entry => renderJournalHistoryItem(entry, entry.id));
            });
        }

        function initializeLocalJournal() {
            const entries = JSON.parse(localStorage.getItem('localJournalEntries')) || [];
            journalHistoryList.innerHTML = '';
            entries.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt)).forEach(entry => renderJournalHistoryItem(entry, entry.id));
        }

        function renderJournalHistoryItem(data, id) {
            const item = document.createElement('div');
            item.className = 'journal-entry-item p-2 rounded hover:bg-white/10 flex justify-between items-center';
            item.dataset.id = id;
            item.dataset.entryText = data.entry;

            const date = data.createdAt?.toDate ? data.createdAt.toDate() : new Date(data.createdAt);
            const dateString = date.toLocaleDateString();

            item.innerHTML = `
                <div>
                    <span class="font-bold">${dateString}</span>
                    <p class="text-sm text-gray-400 truncate">${data.entry.substring(0, 30)}...</p>
                </div>
                <button class="analyze-journal-btn text-purple-400 hover:text-purple-300" title="Analyze with AI"><i data-lucide="brain-circuit" class="w-4 h-4"></i></button>
            `;
            journalHistoryList.appendChild(item);
            lucide.createIcons();

            item.querySelector('.analyze-journal-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                handleJournalAnalysis(data.entry);
            });

            item.addEventListener('click', () => {
                journalEntryTextarea.value = data.entry;
            });
        }

        async function handleJournalAnalysis(entryText) {
            journalAnalysisModal.classList.remove('hidden');
            journalAnalysisContent.innerHTML = '<div class="loader"></div>';
            const prompt = `Analyze this journal entry. Here is the entry: "${entryText}"`;
            const systemInstruction = "You are an AI assistant for self-reflection. Your role is to analyze a journal entry from a compassionate, neutral, and insightful perspective. Identify potential underlying themes, emotions, or thought patterns. Frame your response as gentle observations or reflective questions to encourage deeper thought. **Crucially, you must not provide any form of medical, clinical, psychological, or therapeutic advice, diagnosis, or treatment plan.** You are not a healthcare professional. If the entry mentions suicidal ideation, self-harm, or severe distress, your primary response must be to provide a disclaimer advising the user to seek immediate help from a crisis hotline or a qualified mental health professional.";

            const analysis = await getGeminiResponse(prompt, systemInstruction);
            journalAnalysisContent.textContent = analysis;
        }

        function setupJournalEventListeners() {
            closeJournalAnalysisModal.addEventListener('click', () => journalAnalysisModal.classList.add('hidden'));
            journalAnalysisModal.addEventListener('click', (e) => {
                if (e.target === journalAnalysisModal) journalAnalysisModal.classList.add('hidden');
            });


            journalStorageToggle.addEventListener('change', () => {
                journalStorageMode = journalStorageToggle.checked ? 'server' : 'local';
                localStorage.setItem('journalStorageMode', journalStorageMode);
                initializeJournaling();
            });

            shadowWorkPromptBtn.addEventListener('click', async () => {
                const prompt = "Generate a single, deep, and introspective shadow work prompt. It should be a question that encourages self-reflection on difficult or hidden aspects of the self.";
                shadowWorkPromptBtn.disabled = true;
                shadowWorkPromptBtn.textContent = 'Generating...';
                const shadowPrompt = await getGeminiResponse(prompt);
                journalEntryTextarea.value = shadowPrompt.replace(/['"]+/g, '');
                shadowWorkPromptBtn.disabled = false;
                shadowWorkPromptBtn.textContent = '🔮 New Shadow Work Prompt';
            });

            saveJournalEntryBtn.addEventListener('click', async () => {
                const entryText = journalEntryTextarea.value.trim();
                if (!entryText) return;

                saveJournalEntryBtn.disabled = true;

                if (journalStorageMode === 'server') {
                    if (!db || !currentUserId) {
                        showNotification("Cannot save to server. Please ensure you are connected.", "error");
                        saveJournalEntryBtn.disabled = false;
                        return;
                    }

                    try {
                        // First, perform the safety check. If it fails, the error will be caught.
                        await checkForSuicidalIntent(entryText);

                        // If the check succeeds (or doesn't find anything), save the entry.
                        await addDoc(collection(db, `artifacts/${sanitizedAppId}/users/${currentUserId}/journal`), {
                            entry: entryText, createdAt: serverTimestamp(), userId: currentUserId
                        });

                        journalEntryTextarea.value = '';
                        saveJournalEntryBtn.textContent = 'Saved!';
                        setTimeout(() => { saveJournalEntryBtn.textContent = 'Save Entry'; }, 2000);

                    } catch (error) {
                        console.error("Error during save/flag process:", error);
                        showNotification("An error occurred. The entry was not saved. Please try again.", "error");
                    } finally {
                        saveJournalEntryBtn.disabled = false;
                    }

                } else { // Local storage logic
                    const localEntries = JSON.parse(localStorage.getItem('localJournalEntries')) || [];
                    const newEntry = {
                        id: Date.now().toString(), entry: entryText, createdAt: new Date().toISOString()
                    };
                    localEntries.push(newEntry);
                    localStorage.setItem('localJournalEntries', JSON.stringify(localEntries));
                    initializeLocalJournal();

                    journalEntryTextarea.value = '';
                    saveJournalEntryBtn.textContent = 'Saved!';
                    setTimeout(() => { saveJournalEntryBtn.textContent = 'Save Entry'; }, 2000);
                    saveJournalEntryBtn.disabled = false;
                }
            });

            document.getElementById('sync-journal-btn').addEventListener('click', async () => {
                const user = auth.currentUser;
                if (!user) {
                    showNotification("Please wait for connection to sync.", "error");
                    return;
                }

                const syncBtn = document.getElementById('sync-journal-btn');
                syncBtn.disabled = true;
                syncBtn.textContent = 'Syncing...';

                const localEntries = JSON.parse(localStorage.getItem('localJournalEntries')) || [];
                if (localEntries.length === 0) {
                    showNotification("No local entries to sync.");
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync to Server';
                    return;
                }

                try {
                    const journalRef = collection(db, `artifacts/${sanitizedAppId}/users/${user.uid}/journal`);
                    for (const entry of localEntries) {

                        await checkForSuicidalIntent(entry.entry);
                        await addDoc(journalRef, {
                            entry: entry.entry,
                            createdAt: serverTimestamp(),
                            userId: user.uid
                        });
                    }

                    localStorage.removeItem('localJournalEntries');
                    journalStorageMode = 'server';
                    localStorage.setItem('journalStorageMode', journalStorageMode);
                    initializeJournaling();
                    showNotification("Local entries synced successfully and storage switched to server mode.");

                } catch (error) {
                    console.error("Error syncing journal entries:", error);
                    showNotification("An error occurred during sync. Please try again.", "error");
                } finally {
                    syncBtn.disabled = false;
                    syncBtn.textContent = 'Sync to Server';
                }
            });
        }

        // --- Study Help Logic (ENHANCED with PDF Support) ---
        const studyHelpBtn = document.getElementById('study-help-btn');
        const studyHelpModal = document.getElementById('study-help-modal');
        const closeStudyHelpModal = document.getElementById('close-study-help-modal');
        const studyFileUpload = document.getElementById('study-file-upload');
        const studyFileName = document.getElementById('study-file-name');
        const studyUploadView = document.getElementById('study-upload-view');
        const studyChatView = document.getElementById('study-chat-view');
        const studyChatFileName = document.getElementById('study-chat-file-name');
        const studyEndChatBtn = document.getElementById('study-end-chat-btn');
        const studyChatMessages = document.getElementById('study-chat-messages');
        const studyChatInput = document.getElementById('study-chat-input');
        const studyChatSendBtn = document.getElementById('study-chat-send-btn');

        let documentChunks = [];

        function chunkText(text, chunkSize = 2000, overlap = 200) {
            const chunks = [];
            let i = 0;
            while (i < text.length) {
                chunks.push(text.slice(i, i + chunkSize));
                i += chunkSize - overlap;
            }
            return chunks;
        }

        function findRelevantChunks(query, chunks, topN = 3) {
            const queryWords = new Set(query.toLowerCase().split(/\s+/).filter(w => w.length > 2));
            const scoredChunks = chunks.map((chunk) => {
                let score = 0;
                const chunkWords = new Set(chunk.toLowerCase().split(/\s+/));
                for (const word of queryWords) {
                    if (chunkWords.has(word)) score++;
                }
                return { score, chunk };
            });

            scoredChunks.sort((a, b) => b.score - a.score);
            let context = "";
            for (let i = 0; i < Math.min(topN, scoredChunks.length); i++) {
                if (scoredChunks[i].score > 0) {
                    context += scoredChunks[i].chunk + "\n\n";
                }
            }
            return context.trim();
        }

        async function getTextFromPdf(arrayBuffer) {
            const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
            const pdf = await loadingTask.promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
            }
            return fullText;
        }

        function initializeStudyHelp() {
            function resetStudyModal() {
                studyUploadView.classList.remove('hidden');
                studyChatView.classList.add('hidden');
                studyChatMessages.innerHTML = '';
                studyChatInput.value = '';
                studyFileName.textContent = 'PDF, TXT, MD, etc. (MAX. 5MB)';
                studyFileUpload.value = '';
                documentChunks = [];
            }

            studyHelpBtn.addEventListener('click', () => {
                studyHelpModal.classList.remove('hidden');
                lucide.createIcons();
            });
            closeStudyHelpModal.addEventListener('click', () => {
                studyHelpModal.classList.add('hidden');
                resetStudyModal();
            });
            studyHelpModal.addEventListener('click', (e) => {
                if (e.target === studyHelpModal) {
                    studyHelpModal.classList.add('hidden');
                    resetStudyModal();
                }
            });

            function processFileContent(content, fileName) {
                documentChunks = chunkText(content);
                const processingMessage = studyChatMessages.querySelector('.processing-indicator');
                if (processingMessage) processingMessage.remove();

                studyUploadView.classList.add('hidden');
                studyChatView.classList.remove('hidden');
                studyChatFileName.textContent = fileName;
                displayStudyChatMessage(`File "${fileName}" is ready. Ask me anything about its content.`, 'ai');
            }

            studyFileUpload.addEventListener('change', (e) => {
                if (e.target.files.length === 0) return;
                const file = e.target.files[0];
                if (file.size > 5 * 1024 * 1024) {
                    showNotification("File is too large (max 5MB).", "error");
                    return resetStudyModal();
                }

                const reader = new FileReader();
                if (file.type === 'application/pdf') {
                    displayStudyChatMessage('Processing PDF... this may take a moment.', 'ai', true);
                    reader.onload = async (event) => {
                        try {
                            processFileContent(await getTextFromPdf(event.target.result), file.name);
                        } catch (err) {
                            console.error("Error parsing PDF:", err);
                            showNotification("Could not parse the PDF file.", "error");
                            resetStudyModal();
                        }
                    };
                    reader.readAsArrayBuffer(file);
                } else if (file.type.startsWith('text/') || file.name.endsWith('.md')) {
                    reader.onload = (event) => processFileContent(event.target.result, file.name);
                    reader.readAsText(file);
                } else {
                    showNotification("Unsupported file type. Please upload a PDF or plain text file.", "error");
                    resetStudyModal();
                }
            });

            studyEndChatBtn.addEventListener('click', resetStudyModal);

            function displayStudyChatMessage(text, sender, isProcessing = false) {
                const messageContainer = document.createElement('div');
                messageContainer.className = `chat-message ${sender}`;
                if (isProcessing) messageContainer.classList.add('processing-indicator');

                const bubble = document.createElement('div');
                bubble.className = `chat-bubble ${sender === 'user' ? 'user' : 'ai'}`;
                bubble.innerHTML = text; // Use innerHTML for loader
                messageContainer.appendChild(bubble);
                studyChatMessages.appendChild(messageContainer);
                studyChatMessages.scrollTop = studyChatMessages.scrollHeight;
            }

            async function handleStudySendMessage() {
                const userRequest = studyChatInput.value.trim();
                if (!userRequest || documentChunks.length === 0) return;

                displayStudyChatMessage(userRequest, 'user');
                studyChatInput.value = '';
                displayStudyChatMessage('<div class="loader" style="width:20px; height:20px; margin:0;"></div>', 'ai', true);

                let context = '';
                const lowerUserRequest = userRequest.toLowerCase();
                const summaryKeywords = ['what is this', 'summarize', 'summary', 'overview', 'tldr', 'give me the gist', 'what is this document'];

                const isSummaryRequest = summaryKeywords.some(keyword => lowerUserRequest.includes(keyword));

                if (isSummaryRequest) {
                    // For summary requests, use the beginning of the document as context.
                    context = documentChunks.slice(0, 3).join('\n\n');
                } else {
                    // For specific questions, find the most relevant chunks.
                    context = findRelevantChunks(userRequest, documentChunks);
                }

                const systemInstruction = "You are a helpful study assistant. Your primary goal is to answer questions and follow instructions based on the provided text from a document. Analyze the user's entire prompt to understand their request (e.g., 'summarize', 'explain', 'list key points'). Use the provided CONTEXT to formulate your answer. If the user asks a general question like 'What is this document?', use the provided context (which will be from the beginning of the document) to give a summary. If the context doesn't contain the answer for a specific question, clearly state that the information was not found in the provided text.";

                const prompt = context
                    ? `Here is the relevant context from the document:\n\n---\nCONTEXT:\n${context}\n---\n\nNow, please follow the user's request based on this context.\n\nUSER'S REQUEST: "${userRequest}"`
                    : `The user asked: "${userRequest}". However, no relevant section was found in the document to answer this. Inform the user that you couldn't find specifics in the document for their request.`;

                const aiResponse = await getGeminiResponse(prompt, systemInstruction);

                const typingIndicator = studyChatMessages.querySelector('.processing-indicator');
                if (typingIndicator) typingIndicator.remove();

                displayStudyChatMessage(aiResponse, 'ai');
            }

            studyChatSendBtn.addEventListener('click', handleStudySendMessage);
            studyChatInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') handleStudySendMessage();
            });
        }

        // --- Serenity Map Logic ---

        let map;
        let mapMarkers = [];

        function initializeSerenityMap() {
            if (typeof L === 'undefined') {
                document.getElementById('map').innerHTML = `<div class="flex items-center justify-center h-full text-red-400 p-4 text-center">Error: Could not load Leaflet mapping library.</div>`;
                return;
            }
            try {
                var container = L.DomUtil.get('map');
                if (container != null) { container._leaflet_id = null; }
                map = L.map('map').setView([20.5937, 78.9629], 5);
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    maxZoom: 19,
                    attribution: '© <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                }).addTo(map);
                document.getElementById('location-search-btn').addEventListener('click', () => {
                    const query = document.getElementById('location-search-input').value;
                    if (query) searchPlaces(query);
                });
            } catch (e) {
                console.error("Leaflet map initialization failed:", e);
                document.getElementById('map').innerHTML = `<div class="flex items-center justify-center h-full text-red-400 p-4 text-center">Map initialization failed.</div>`;
            }
        }

        function clearMapMarkers() {
            mapMarkers.forEach(marker => map.removeLayer(marker));
            mapMarkers = [];
        }

        async function searchPlaces(query) {
            clearMapMarkers();
            const searchButton = document.getElementById('location-search-btn');
            searchButton.disabled = true;
            searchButton.innerHTML = '<div class="loader" style="width:20px; height:20px; border-width: 2px; margin: auto;"></div>';

            const geminiPrompt = `Find 5 serene public places (like parks, libraries, quiet cafes) in or very near ${query}, India. Respond with ONLY a valid JSON array of objects. Each object must have "name" (string), "lat" (number), and "lon" (number) properties. The coordinates must be accurate. Example: [{"name": "Lodi Garden", "lat": 28.5931, "lon": 77.2196}]`;

            try {
                const responseText = await getGeminiResponse(geminiPrompt, "You are a helpful location finding assistant. You only respond with JSON.");

                const cleanedResponse = responseText.replace(/```json/g, '').replace(/```/g, '').trim();
                const places = JSON.parse(cleanedResponse);

                if (places && places.length > 0 && places[0].lat && places[0].lon) {
                    map.setView([places[0].lat, places[0].lon], 13);
                    places.forEach(createMapMarker);
                } else {
                    showNotification('The AI could not find any specific quiet locations. Please try a different search.', 'error');
                }
            } catch (error) {
                console.error("Error parsing Gemini response or searching places:", error);
                showNotification("An error occurred while searching. The AI might have returned an invalid format. Please try again.", "error");
            } finally {
                searchButton.disabled = false;
                searchButton.textContent = 'Search';
            }
        }

        function createMapMarker(place) {
            if (!place.lat || !place.lon) return;
            const marker = L.marker([place.lat, place.lon]).addTo(map);
            marker.bindPopup(`<b>${place.name}</b>`);
            mapMarkers.push(marker);
        }
        // --- Music Player Logic ---
        function initializeMusicPlayer() {
            const spotifyBtn = document.getElementById('spotify-btn');
            const ytMusicBtn = document.getElementById('yt-music-btn');
            const musicPlayerContainer = document.getElementById('music-player-container');
            const YOUTUBE_DEFAULT_EMBED_URL = 'https://www.youtube.com/embed/jfKfPfyJRdk';

            // --- YouTube Music Variables & Functions ---
            let tokenClient;
            let gapiReady = false;
            let gsiReady = false;
            let ytSyncError = null;

            function updateYtLoginButtonState() {
                const loginBtn = document.getElementById('yt-login-btn');
                if (!loginBtn) return;
                if (ytSyncError) {
                    loginBtn.disabled = true; loginBtn.textContent = 'Sync Error'; loginBtn.title = ytSyncError; return;
                }
                if (gapiReady && gsiReady) {
                    loginBtn.disabled = false; loginBtn.textContent = 'Sync YouTube Music'; loginBtn.title = 'Login to see your playlists.';
                } else {
                    loginBtn.disabled = true; loginBtn.textContent = 'Loading Sync...'; loginBtn.title = 'Waiting for Google libraries...';
                }
            }
            function initializeGapiClient() {
                if (YOUTUBE_API_KEY.includes('YOUR_')) {
                    ytSyncError = "YouTube API Key is missing."; updateYtLoginButtonState(); return;
                }
                gapi.load('client', () => {
                    gapi.client.init({
                        apiKey: YOUTUBE_API_KEY,
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/youtube/v3/rest'],
                    }).then(() => {
                        gapiReady = true; updateYtLoginButtonState();
                    }).catch(error => {
                        console.error("GAPI client init error:", error);
                        ytSyncError = `GAPI Error: The YouTube Data API is not enabled.`; updateYtLoginButtonState();
                    });
                });
            }
            function loadGapiScript() {
                const script = document.createElement('script'); script.src = 'https://apis.google.com/js/api.js';
                script.onload = initializeGapiClient; document.body.appendChild(script);
            }
            function initializeGsiClient() {
                if (typeof google === 'undefined' || !google.accounts) {
                    ytSyncError = "Google script failed to load."; updateYtLoginButtonState(); return;
                }
                if (YT_MUSIC_CLIENT_ID.includes('YOUR_')) {
                    ytSyncError = "YouTube Music OAuth Client ID is missing."; updateYtLoginButtonState(); return;
                }
                try {
                    tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: YT_MUSIC_CLIENT_ID, scope: 'https://www.googleapis.com/auth/youtube.readonly', callback: handleAuthResponse
                    });
                    gsiReady = true; loadGapiScript();
                } catch (e) {
                    console.error("GSI Init Failed for YT Music:", e);
                    ytSyncError = "GSI Init Failed for YT Music. Check Client ID."; updateYtLoginButtonState();
                }
            }
            async function handleAuthResponse(tokenResponse) {
                if (tokenResponse.access_token) {
                    gapi.client.setToken(tokenResponse);
                    musicPlayerContainer.innerHTML = '<div class="loader mx-auto mt-16"></div>';
                    try {
                        const response = await gapi.client.youtube.playlists.list({ part: 'snippet', mine: true, maxResults: 50 });
                        if (response.result.items && response.result.items.length > 0) {
                            renderUserPlaylists(response.result.items);
                        } else {
                            musicPlayerContainer.innerHTML = `<div class="text-center p-4">No public playlists found. <button id="yt-logout-btn" class="text-sm text-red-400 hover:text-white block mx-auto mt-2">Logout</button></div>`;
                            document.getElementById('yt-logout-btn').addEventListener('click', handleYtLogout);
                        }
                    } catch (err) {
                        console.error("Error fetching YT playlists:", err);
                        musicPlayerContainer.innerHTML = `<div class="text-center p-4">Could not fetch playlists. <button id="yt-logout-btn" class="mx-auto block text-sm text-gray-400 hover:text-white mt-2">Logout</button></div>`;
                        document.getElementById('yt-logout-btn').addEventListener('click', handleYtLogout);
                    }
                } else {
                    console.error("Auth response did not contain access token.", tokenResponse);
                    musicPlayerContainer.innerHTML = `<div class="text-center p-4">Authentication failed. Please try again.</div>`;
                }
            }
            function handleYtLogin() {
                if (gapiReady && gsiReady && tokenClient) tokenClient.requestAccessToken({ prompt: 'consent' });
            }
            function handleYtLogout() {
                gapi.client.setToken(null); renderDefaultYtPlayer();
            }

            async function fetchPlaylistItems(playlistId, container) {
                try {
                    const response = await gapi.client.youtube.playlistItems.list({
                        part: 'snippet',
                        playlistId: playlistId,
                        maxResults: 50
                    });
                    renderPlaylistItems(response.result.items, container);
                } catch (err) {
                    console.error("Error fetching playlist items:", err);
                    container.innerHTML = `<p class="text-xs text-gray-400 p-2">Could not load videos.</p>`;
                }
            }

            function renderPlaylistItems(items, container) {
                const videoList = document.createElement('div');
                videoList.className = "space-y-2";

                if (!items || items.length === 0) {
                    container.innerHTML = `<p class="text-xs text-gray-400 p-2">This playlist is empty.</p>`;
                    return;
                }

                videoList.innerHTML = items.map(item => {
                    const snippet = item.snippet;
                    const videoId = snippet.resourceId.videoId;
                    const title = snippet.title;
                    const thumbnailUrl = snippet.thumbnails.default.url;
                    // Skip deleted or private videos
                    if (title === "Deleted video" || title === "Private video") return '';

                    return `
                        <button class="yt-video-item flex items-center gap-2 w-full text-left p-1.5 hover:bg-white/10 rounded transition-colors duration-200" data-video-id="${videoId}">
                            <img src="${thumbnailUrl}" class="w-10 h-10 rounded object-cover" alt="Video thumbnail">
                            <span class="flex-1 text-xs font-medium truncate">${title}</span>
                        </button>
                    `;
                }).join('');

                container.innerHTML = '';
                container.appendChild(videoList);

                container.querySelectorAll('.yt-video-item').forEach(item => {
                    item.addEventListener('click', () => {
                        document.getElementById('music-player-iframe').src = `https://www.youtube.com/embed/${item.dataset.videoId}?autoplay=1`;
                    });
                });
            }

            async function renderUserPlaylists(playlists) {
                musicPlayerContainer.innerHTML = `
                    <div class="flex flex-col h-full bg-black/20 rounded-lg">
                        <div class="w-full h-2/5 relative">
                             <iframe id="music-player-iframe" class="rounded-t-lg w-full h-full" src="https://www.youtube.com/embed/videoseries?list=${playlists[0].id}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
                        </div>
                        <div class="flex-1 flex flex-row min-h-0">
                            <!-- Left: Playlist List -->
                            <div class="w-1/2 flex flex-col border-r border-white/10">
                                <div class="flex justify-between items-center p-2 border-b border-white/10">
                                    <h4 class="font-bold text-base truncate">Your Playlists</h4>
                                    <button id="yt-logout-btn" class="text-xs text-gray-400 hover:text-white flex-shrink-0">Logout</button>
                                </div>
                                <div id="yt-playlist-list" class="flex-1 overflow-y-auto p-1 space-y-1">
                                    ${playlists.map((p, index) => `
                                        <button class="yt-playlist-item flex items-center gap-2 w-full text-left p-1.5 hover:bg-white/10 rounded transition-colors duration-200 ${index === 0 ? 'bg-white/20' : ''}" data-playlist-id="${p.id}" title="${p.snippet.title}">
                                            <img src="${p.snippet.thumbnails.default.url}" class="w-10 h-10 rounded object-cover" alt="Playlist thumbnail">
                                            <span class="flex-1 text-xs font-medium truncate">${p.snippet.title}</span>
                                        </button>
                                    `).join('')}
                                </div>
                            </div>
                            <!-- Right: Video List -->
                            <div class="w-1/2 flex flex-col">
                                 <div class="p-2 border-b border-white/10">
                                     <h4 id="yt-video-list-header" class="font-bold text-base truncate">${playlists[0].snippet.title}</h4>
                                 </div>
                                 <div id="yt-video-list" class="flex-1 overflow-y-auto p-1">
                                     <div class="loader"></div>
                                 </div>
                            </div>
                        </div>
                    </div>`;

                document.getElementById('yt-logout-btn').addEventListener('click', handleYtLogout);
                const videoListContainer = document.getElementById('yt-video-list');
                const videoListHeader = document.getElementById('yt-video-list-header');

                const playlistItems = document.querySelectorAll('.yt-playlist-item');
                playlistItems.forEach(item => {
                    item.addEventListener('click', () => {
                        playlistItems.forEach(el => el.classList.remove('bg-white/20'));
                        item.classList.add('bg-white/20');

                        const playlistId = item.dataset.playlistId;
                        const playlistTitle = item.getAttribute('title');

                        videoListHeader.textContent = playlistTitle;
                        videoListContainer.innerHTML = '<div class="loader"></div>';
                        document.getElementById('music-player-iframe').src = `https://www.youtube.com/embed/videoseries?list=${playlistId}`;
                        fetchPlaylistItems(playlistId, videoListContainer);
                    });
                });
                // Initially load videos for the first playlist
                fetchPlaylistItems(playlists[0].id, videoListContainer);
            }

            // --- Spotify Variables & Functions ---
            const SPOTIFY_REDIRECT_URI = window.location.origin + window.location.pathname;

            async function redirectToAuthCodeFlow() {
                const verifier = generateCodeVerifier(128);
                const challenge = await generateCodeChallenge(verifier);
                localStorage.setItem("spotify_verifier", verifier);
                const params = new URLSearchParams();
                params.append("client_id", SPOTIFY_CLIENT_ID);
                params.append("response_type", "code");
                params.append("redirect_uri", SPOTIFY_REDIRECT_URI);
                params.append("scope", "playlist-read-private playlist-read-collaborative");
                params.append("code_challenge_method", "S256");
                params.append("code_challenge", challenge);
                document.location = `https://accounts.spotify.com/authorize?${params.toString()}`;
            }
            async function getSpotifyToken(code) {
                const verifier = localStorage.getItem("spotify_verifier");
                const params = new URLSearchParams();
                params.append("client_id", SPOTIFY_CLIENT_ID);
                params.append("grant_type", "authorization_code");
                params.append("code", code);
                params.append("redirect_uri", SPOTIFY_REDIRECT_URI);
                params.append("code_verifier", verifier);
                try {
                    const result = await fetch("https://accounts.spotify.com/api/token", { method: "POST", headers: { "Content-Type": "application/x-www-form-urlencoded" }, body: params });
                    const { access_token } = await result.json();
                    localStorage.setItem('spotify_access_token', access_token);
                    await renderSpotifyPlayer();
                } catch (e) { console.error("Could not get Spotify token", e); }
            }
            async function fetchSpotifyPlaylists() {
                const token = localStorage.getItem('spotify_access_token');
                if (!token) return;
                try {
                    const result = await fetch("https://api.spotify.com/v1/me/playlists", { method: "GET", headers: { Authorization: `Bearer ${token}` } });
                    if (result.status === 401) { handleSpotifyLogout(); return; }
                    const data = await result.json();
                    if (data.items && data.items.length > 0) {
                        renderSpotifyUserPlaylists(data.items);
                    } else {
                        renderNoSpotifyPlaylistsMessage();
                    }
                } catch (e) { console.error("Could not fetch Spotify playlists", e); }
            }
            function handleSpotifyLogout() {
                localStorage.removeItem('spotify_access_token');
                renderSpotifyPlayer();
            }
            function renderNoSpotifyPlaylistsMessage() {
                musicPlayerContainer.innerHTML = `
                    <div class="flex flex-col items-center justify-center h-full gap-4 text-center">
                        <i data-lucide="music-4" class="w-16 h-16 text-gray-500"></i>
                        <h4 class="text-lg font-bold">No Playlists Found</h4>
                        <p class="text-sm text-gray-400">We couldn't find any playlists in your Spotify account.</p>
                        <button id="spotify-logout-btn" class="mt-4 bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 text-sm">Logout from Spotify</button>
                    </div>
                `;
                document.getElementById('spotify-logout-btn').addEventListener('click', handleSpotifyLogout);
                lucide.createIcons();
            }
            function renderSpotifyUserPlaylists(playlists) {
                musicPlayerContainer.innerHTML = `
                    <div class="flex flex-col h-full bg-black/20 rounded-lg">
                        <iframe id="spotify-player-iframe" class="rounded-t-lg w-full h-3/5" src="https://open.spotify.com/embed/playlist/${playlists[0].id}" frameborder="0" allow="encrypted-media"></iframe>
                        <div class="flex-1 flex flex-col min-h-0">
                            <div class="flex justify-between items-center p-2 border-b border-white/10"><h4 class="font-bold text-base">Your Playlists</h4><button id="spotify-logout-btn" class="text-xs text-gray-400 hover:text-white">Logout</button></div>
                            <div class="flex-1 overflow-y-auto p-1">
                                ${playlists.map(p => `<button class="spotify-playlist-item w-full text-left p-2 hover:bg-white/10 rounded text-sm truncate" data-playlist-id="${p.id}" title="${p.name}">${p.name}</button>`).join('')}
                            </div>
                        </div>
                    </div>`;
                document.getElementById('spotify-logout-btn').addEventListener('click', handleSpotifyLogout);
                document.querySelectorAll('.spotify-playlist-item').forEach(item => {
                    item.addEventListener('click', () => {
                        document.getElementById('spotify-player-iframe').src = `https://open.spotify.com/embed/playlist/${item.dataset.playlistId}`;
                    });
                });
            }

            // --- Player Rendering Functions ---
            async function renderSpotifyPlayer() {
                ytMusicBtn.classList.remove('ring-2', 'ring-white');
                spotifyBtn.classList.add('ring-2', 'ring-white');
                const token = localStorage.getItem('spotify_access_token');
                if (token) {
                    musicPlayerContainer.innerHTML = '<div class="loader mx-auto mt-16"></div>';
                    await fetchSpotifyPlaylists();
                } else {
                    const isClientIdSet = SPOTIFY_CLIENT_ID && !SPOTIFY_CLIENT_ID.includes('YOUR_');
                    const savedSpotifyUrl = localStorage.getItem('spotifyPlaylistUrl') || 'https://open.spotify.com/embed/playlist/37i9dQZF1DX4sWSpwq3LiO';
                    musicPlayerContainer.innerHTML = `
                        <div class="flex flex-col h-full gap-2">
                            <iframe id="spotify-iframe" class="rounded-lg w-full flex-1" src="${savedSpotifyUrl}" title="Spotify Playlist" frameborder="0" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>
                            <div class="flex flex-col gap-3 pt-2 border-t border-white/10">
                                <div class="flex gap-2">
                                    <input type="text" id="spotify-link-input" placeholder="Paste Public Playlist Link" class="w-full bg-[#2E3338] p-2 rounded border border-[#4A5568] focus:outline-none focus:ring-2 focus:ring-green-400 text-sm">
                                    <button id="spotify-link-save-btn" class="bg-[#1DB954] text-white px-3 py-1 rounded hover:bg-[#1aaf54] text-sm">Set</button>
                                </div>
                                <button id="spotify-login-btn" class="w-full bg-[#1DB954] text-white px-4 py-2 rounded hover:bg-[#1aaf54] text-sm ${!isClientIdSet ? 'opacity-50 cursor-not-allowed' : ''}" ${!isClientIdSet ? 'disabled' : ''}>Sync Your Spotify Playlists</button>
                                ${!isClientIdSet ? '<p class="text-xs text-center text-gray-400">Add Spotify Client ID in code to enable sync.</p>' : ''}
                            </div>
                        </div>`;
                    if (isClientIdSet) document.getElementById('spotify-login-btn').addEventListener('click', redirectToAuthCodeFlow);
                    document.getElementById('spotify-link-save-btn').addEventListener('click', () => {
                        const input = document.getElementById('spotify-link-input');
                        const link = input.value.trim();
                        if (link.startsWith('https://open.spotify.com/playlist/')) {
                            const playlistId = new URL(link).pathname.split('/').pop();
                            if (playlistId) {
                                const embedUrl = `https://open.spotify.com/embed/playlist/${playlistId}`;
                                document.getElementById('spotify-iframe').src = embedUrl;
                                localStorage.setItem('spotifyPlaylistUrl', embedUrl);
                                input.value = ''; input.placeholder = "Playlist updated!";
                            }
                        }
                    });
                }
            }
            function renderDefaultYtPlayer() {
                spotifyBtn.classList.remove('ring-2', 'ring-white');
                ytMusicBtn.classList.add('ring-2', 'ring-white');
                musicPlayerContainer.innerHTML = `<div class="flex flex-col items-center justify-center h-full gap-4"> <iframe class="rounded-lg w-full h-4/5" src="${YOUTUBE_DEFAULT_EMBED_URL}" title="YouTube Music Mix" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> <button id="yt-login-btn" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600" disabled>Loading Sync...</button> </div>`;
                const loginBtn = document.getElementById('yt-login-btn');
                if (loginBtn) { loginBtn.addEventListener('click', handleYtLogin); updateYtLoginButtonState(); }
            }

            // --- Initialization Logic ---
            const params = new URLSearchParams(window.location.search);
            if (params.get("code")) {
                const isSpotify = !params.get("scope"); // Google's redirect includes a 'scope' param
                if (isSpotify) {
                    getSpotifyToken(params.get("code"));
                    history.replaceState({}, document.title, window.location.pathname);
                }
            }
            spotifyBtn.addEventListener('click', renderSpotifyPlayer);
            ytMusicBtn.addEventListener('click', renderDefaultYtPlayer);
            if (window.googleGsiIsReady) initializeGsiClient();
            else window.addEventListener('google-gsi-loaded', initializeGsiClient, { once: true });
            renderDefaultYtPlayer();
        }

        function initializeOfflineCopingKit() {
            const downloadAllBtn = document.getElementById('download-all-kit-btn');
            const downloadAllText = document.getElementById('download-all-text');
            const toggleDropdownBtn = document.getElementById('toggle-kit-dropdown-btn');
            const dropdownMenu = document.getElementById('coping-kit-dropdown-menu');
            const kitItemBtns = document.querySelectorAll('.kit-item-btn');

            // --- Content Generation Functions ---

            function getContactsContent() {
                return `
EMERGENCY CONTACTS & HELPLINES (INDIA)
=======================================
Mental Health Support:
- Tele MANAS: 14416 or 1800-891-4416
- Vandrevala Foundation: 1800-233-3330 or 9999666555 (WhatsApp)
- The Samaritans Mumbai: +91 84229 84528 / +91 84229 84529 / +91 84229 84530
- Aasra: +91-9820466726
Emergency Services:
- National Emergency Number: 112
- Police: 100
- Fire: 101
- Ambulance: 102 / 108
Women Helpline:
- National Commission for Women: 181 or 7827170170 (WhatsApp)
Child Helpline:
- Childline India: 1098
Add your personal emergency contacts below:
- Friend/Family 1: [Enter Name and Number]
- Friend/Family 2: [Enter Name and Number]
- Doctor/Therapist: [Enter Name and Number]
                `.trim();
            }

            function getExercisesContent() {
                return `
SIMPLE CALMING EXERCISES
========================
** 1. Box Breathing **
A simple technique to calm your nervous system.
1. Breathe In: Slowly inhale through your nose for 4 seconds.
2. Hold: Hold your breath for 4 seconds.
3. Breathe Out: Slowly exhale through your mouth for 4 seconds.
4. Hold: Hold your breath for 4 seconds.
5. Repeat: Continue for a few minutes until you feel centered.

** 2. 4-7-8 Breathing **
A technique to promote relaxation and help with sleep.
1. Exhale completely through your mouth, making a whoosh sound.
2. Close your mouth and inhale quietly through your nose for a count of 4.
3. Hold your breath for a count of 7.
4. Exhale completely through your mouth, making a whoosh sound to a count of 8.
5. This is one breath. Inhale again and repeat the cycle three more times.

** 3. The 5-4-3-2-1 Grounding Technique **
Use this to ground yourself when you feel overwhelmed. Acknowledge:
- 5 things you can SEE around you.
- 4 things you can TOUCH.
- 3 things you can HEAR.
- 2 things you can SMELL.
- 1 thing you can TASTE.
                `.trim();
            }

            function getAffirmationsContent() {
                return `
POSITIVE AFFIRMATIONS
=====================
Repeat these to yourself when you need a boost.

- I am capable of handling challenges.
- I am worthy of peace and happiness.
- I choose to be kind to myself.
- I am resilient and can overcome this.
- My feelings are valid, and I allow myself to feel them.
- I am in control of my own life.
- I am proud of the person I am becoming.
- It is enough to do my best.
                `.trim();
            }

            function getJournalPromptsContent() {
                return `
5-MINUTE JOURNAL PROMPTS
========================
Use these when you don't know what to write.

1. What is one small thing that brought you joy today?
2. Write down something you are looking forward to this week.
3. What is a challenge you recently overcame, no matter how small?
4. Describe a place where you feel completely at peace.
5. What is one thing you can do today to take care of yourself?
6. Write a letter of gratitude to a part of your body.
7. What is a quality you admire in others that you also see in yourself?
                `.trim();
            }

            async function generateHopeCardBlob() {
                const canvas = document.createElement('canvas');
                canvas.width = 800; canvas.height = 400;
                const ctx = canvas.getContext('2d');
                const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                gradient.addColorStop(0, '#434343'); gradient.addColorStop(1, '#000000');
                ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height);
                const quotes = ["This too shall pass.", "You are stronger than you think.", "Just one step at a time.", "Breathe. You've got this.", "It's okay not to be okay.", "You are not alone."];
                const quote = quotes[Math.floor(Math.random() * quotes.length)];
                ctx.fillStyle = 'white'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.font = 'bold 48px sans-serif';
                ctx.fillText(quote, canvas.width / 2, canvas.height / 2);
                ctx.font = '16px sans-serif'; ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.fillText('Your daily reminder from the Green Dashboard', canvas.width / 2, canvas.height - 30);
                return new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
            }

            async function generateMandalaBlob() {
                const canvas = document.createElement('canvas');
                const size = 600;
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                const centerX = size / 2;
                const centerY = size / 2;
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, size, size);
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1.5;

                const segments = 12;
                for (let i = 0; i < segments; i++) {
                    ctx.save();
                    ctx.translate(centerX, centerY);
                    ctx.rotate((Math.PI * 2 / segments) * i);
                    // Draw a pattern
                    ctx.beginPath();
                    ctx.arc(0, 100, 50, 0, Math.PI * 1.5);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(0, -250);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(0, -200, 30, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.restore();
                }
                return new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
            }


            // --- Download Logic ---

            function downloadFile(filename, content) {
                const blob = (content instanceof Blob) ? content : new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // --- Event Listeners ---

            toggleDropdownBtn.addEventListener('click', () => {
                dropdownMenu.classList.toggle('show');
                toggleDropdownBtn.classList.toggle('open');
            });

            kitItemBtns.forEach(btn => {
                btn.addEventListener('click', async () => {
                    const item = btn.dataset.kitItem;
                    switch (item) {
                        case 'contacts': downloadFile('emergency_contacts.txt', getContactsContent()); break;
                        case 'exercises': downloadFile('calming_exercises.txt', getExercisesContent()); break;
                        case 'affirmations': downloadFile('positive_affirmations.txt', getAffirmationsContent()); break;
                        case 'prompts': downloadFile('5_minute_journal_prompts.txt', getJournalPromptsContent()); break;
                        case 'hope-card': downloadFile('hope_card.png', await generateHopeCardBlob()); break;
                        case 'mandala': downloadFile('mindfulness_mandala.png', await generateMandalaBlob()); break;
                    }
                });
            });

            downloadAllBtn.addEventListener('click', async () => {
                downloadAllBtn.disabled = true;
                downloadAllText.textContent = 'Zipping...';

                try {
                    const zip = new JSZip();
                    zip.file('emergency_contacts.txt', getContactsContent());
                    zip.file('calming_exercises.txt', getExercisesContent());
                    zip.file('positive_affirmations.txt', getAffirmationsContent());
                    zip.file('5_minute_journal_prompts.txt', getJournalPromptsContent());

                    const hopeCardBlob = await generateHopeCardBlob();
                    zip.file('hope_card.png', hopeCardBlob);

                    const mandalaBlob = await generateMandalaBlob();
                    zip.file('mindfulness_mandala.png', mandalaBlob);

                    const zipContent = await zip.generateAsync({ type: "blob" });
                    downloadFile('Coping_Kit.zip', zipContent);

                } catch (error) {
                    console.error("Error creating zip file:", error);
                    showNotification("Could not create zip file.", "error");
                } finally {
                    downloadAllBtn.disabled = false;
                    downloadAllText.textContent = 'All';
                }
            });
        }

        function initializeScreening() {
            const openBtn = document.getElementById('open-screening-btn');
            const modal = document.getElementById('screening-modal');
            const closeBtn = document.getElementById('close-screening-modal');
            const startBtn = document.getElementById('start-screening-btn');
            const introView = document.getElementById('screening-intro-view');
            const questionsView = document.getElementById('screening-questions-view');
            const resultsView = document.getElementById('screening-results-view');
            const questionText = document.getElementById('screening-question-text');
            const optionsContainer = document.getElementById('screening-options');
            const nextBtn = document.getElementById('screening-next-btn');
            const backBtn = document.getElementById('screening-back-btn');
            const progressBar = document.getElementById('screening-progress-bar');
            const counter = document.getElementById('screening-question-counter');
            const verificationBadge = document.getElementById('user-verification-badge');

            const questions = [
                // PHQ-9 Questions
                { text: "Little interest or pleasure in doing things?", type: 'phq' },
                { text: "Feeling down, depressed, or hopeless?", type: 'phq' },
                { text: "Trouble falling or staying asleep, or sleeping too much?", type: 'phq' },
                { text: "Feeling tired or having little energy?", type: 'phq' },
                { text: "Poor appetite or overeating?", type: 'phq' },
                { text: "Feeling bad about yourself — or that you are a failure or have let yourself or your family down?", type: 'phq' },
                { text: "Trouble concentrating on things, such as reading the newspaper or watching television?", type: 'phq' },
                { text: "Moving or speaking so slowly that other people could have noticed? Or the opposite — being so fidgety or restless that you have been moving around a lot more than usual?", type: 'phq' },
                { text: "Thoughts that you would be better off dead, or of hurting yourself in some way?", type: 'phq' },
                // GAD-7 Questions
                { text: "Feeling nervous, anxious, or on edge?", type: 'gad' },
                { text: "Not being able to stop or control worrying?", type: 'gad' },
                { text: "Worrying too much about different things?", type: 'gad' },
                { text: "Trouble relaxing?", type: 'gad' },
                { text: "Being so restless that it is hard to sit still?", type: 'gad' },
                { text: "Becoming easily annoyed or irritable?", type: 'gad' },
                { text: "Feeling afraid, as if something awful might happen?", type: 'gad' }
            ];
            const options = ["Not at all", "Several days", "More than half the days", "Nearly every day"];
            let currentQuestionIndex = 0;
            let answers = new Array(questions.length).fill(null);

            function showView(view) {
                introView.classList.add('hidden');
                questionsView.classList.add('hidden');
                resultsView.classList.add('hidden');
                view.classList.remove('hidden');
            }

            function renderQuestion() {
                const question = questions[currentQuestionIndex];
                questionText.textContent = question.text;
                optionsContainer.innerHTML = '';
                options.forEach((option, index) => {
                    const isChecked = answers[currentQuestionIndex] === index;
                    optionsContainer.innerHTML += `
                        <div>
                            <input type="radio" id="option${index}" name="screening-option" value="${index}" class="sr-only" ${isChecked ? 'checked' : ''}>
                            <label for="option${index}" class="screening-option-label block p-3 rounded-lg border border-gray-600">${option}</label>
                        </div>
                    `;
                });
                updateProgress();
                nextBtn.disabled = answers[currentQuestionIndex] === null;
                optionsContainer.querySelectorAll('input[name="screening-option"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        answers[currentQuestionIndex] = parseInt(e.target.value);
                        nextBtn.disabled = false;
                    });
                });
            }

            function updateProgress() {
                const progress = ((currentQuestionIndex + 1) / questions.length) * 100;
                progressBar.style.width = `${progress}%`;
                counter.textContent = `Question ${currentQuestionIndex + 1} of ${questions.length}`;
                backBtn.disabled = currentQuestionIndex === 0;
            }

            function calculateScores() {
                let phqScore = 0;
                let gadScore = 0;
                answers.forEach((answer, index) => {
                    if (questions[index].type === 'phq') {
                        phqScore += answer;
                    } else {
                        gadScore += answer;
                    }
                });
                return { phqScore, gadScore };
            }

            async function generateAndSendReport(phqScore, gadScore, rawAnswers) {
                const systemInstruction = `You are a mental health assistant. Your task is to analyze the results of a PHQ-9 and GAD-7 screening and generate a concise, neutral, and informative report for a wellness coordinator. DO NOT provide a diagnosis. Stick to observational language.`;
                const prompt = `A student has completed a mental health screening. Analyze the following results and generate a report.
        **Scores:**
        - PHQ-9 Score: ${phqScore} out of 27
        - GAD-7 Score: ${gadScore} out of 21
        **Raw Answer Details:**
        - PHQ-9 Answers: ${JSON.stringify(rawAnswers?.phq9 || [])}
        - GAD-7 Answers: ${JSON.stringify(rawAnswers?.gad7 || [])}
        **Task:**
        1. State scores and severity levels.
        2. Identify top 2-3 most frequent symptoms (scores of 2 or 3).
        3. Note the response to PHQ-9 Question 9 (self-harm), if > 0.
        4. Conclude with a neutral summary.`;

                try {
                    const reportText = await getGeminiResponse(prompt, systemInstruction);

                    if (!db || !currentUserId) {
                        throw new Error("User is not properly authenticated.");
                    }

                    const reportRef = collection(db, `artifacts/${sanitizedAppId}/public/data/mental_health_reports`);
                    await addDoc(reportRef, {
                        userId: currentUserId,
                        report: reportText,
                        phqScore,
                        gadScore,
                        createdAt: serverTimestamp()
                    });

                    // persist local flag
                    localStorage.setItem(`screeningCompleted_${currentUserId}`, 'true');

                    // SAFELY toggle UI elements (guard each lookup)
                    const introText = document.getElementById('screening-intro-text');
                    if (introText) introText.classList.add('hidden');

                    const completeText = document.getElementById('screening-complete-text');
                    if (completeText) completeText.classList.remove('hidden');

                    const btnText = document.getElementById('screening-btn-text');
                    if (btnText) btnText.textContent = "Retake Screening";

                    const verificationBadgeEl = document.getElementById('user-verification-badge');
                    if (verificationBadgeEl) verificationBadgeEl.classList.remove('hidden');

                    const screeningModalEl = document.getElementById('screening-modal');
                    if (screeningModalEl) screeningModalEl.classList.add('hidden');

                    // If you show the results view, ensure its element exists
                    const resultsViewEl = document.getElementById('screening-results-view');
                    if (resultsViewEl) {
                        // keep the "completed" view visible, or turn off any loader inside it
                        resultsViewEl.classList.remove('hidden');
                    }

                    showNotification("Screening submitted successfully!", "success");

                } catch (error) {
                    console.error("Error submitting screening report:", error);
                    showNotification("Failed to submit screening. Check console for details.", "error");
                }
                // NOTE: intentionally no reference to submitScreeningBtn here
            }



            async function checkVerificationStatus() {
                if (db && currentUserId) {
                    const userProfileRef = doc(db, `artifacts/${sanitizedAppId}/users/${currentUserId}/profile`, 'main');
                    const docSnap = await getDoc(userProfileRef);
                    if (docSnap.exists() && docSnap.data().screeningCompleted) {
                        verificationBadge.classList.remove('hidden');
                    } else {
                        verificationBadge.classList.add('hidden');
                    }
                }
            }


            function resetScreening() {
                currentQuestionIndex = 0;
                answers.fill(null);
            }

            openBtn.addEventListener('click', () => modal.classList.remove('hidden'));
            closeBtn.addEventListener('click', () => {
                modal.classList.add('hidden');
                showView(introView);
                resetScreening();
            });
            startBtn.addEventListener('click', () => {
                showView(questionsView);
                renderQuestion();
            });
            nextBtn.addEventListener('click', () => {
                if (currentQuestionIndex < questions.length - 1) {
                    currentQuestionIndex++;
                    renderQuestion();
                } else {
                    // build scores + raw answers then call the report generator
                    const { phqScore, gadScore } = calculateScores();

                    // build raw answers mapped into phq9/gad7 arrays in the correct order
                    const phqRaw = questions
                        .map((q, i) => ({ type: q.type, val: answers[i] }))
                        .filter(x => x.type === 'phq')
                        .map(x => x.val ?? 0);

                    const gadRaw = questions
                        .map((q, i) => ({ type: q.type, val: answers[i] }))
                        .filter(x => x.type === 'gad')
                        .map(x => x.val ?? 0);

                    const rawAnswers = { phq9: phqRaw, gad7: gadRaw };

                    showView(resultsView);
                    generateAndSendReport(phqScore, gadScore, rawAnswers);
                }
            });

            backBtn.addEventListener('click', () => {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    renderQuestion();
                }
            });

            checkVerificationStatus();

        }



        // --- General Initialization ---
        // REPLACE the second DOMContentLoaded listener (around line 3866) with this:

        document.addEventListener('DOMContentLoaded', async () => {
            // All these just set up non-Firebase DOM elements and listeners
            initializePage();
            loadProfilePic();
            initializeMusicPlayer();
            loadAiChatHistory();
            populateEmotePicker();
            initializeSerenityMap();
            initializeAiChat();
            initializeProfilePic();
            setupAssignmentEventListeners();
            setupJournalEventListeners();
            initializeStudyHelp();
            initializeMeditationWidget();
            initializeOfflineCopingKit();

            // These calls were in the deleted DOMContentLoaded and are needed
            initializeViewSwitcher();
            initializePeerChat();
            initializeUserProfilePopup();
            initializeContextMenu();
            initializeMediaSending();
            initializeEmojiPanel();
            initializeChannelManagement();

            // SOS button logic
            const sosBtn = document.getElementById('sos-btn');
            const sosSidebar = document.getElementById('sos-sidebar');
            const closeSosSidebarBtn = document.getElementById('close-sos-sidebar');

            sosBtn.addEventListener('click', () => {
                sosSidebar.classList.remove('translate-x-full');
            });
            closeSosSidebarBtn.addEventListener('click', () => {
                sosSidebar.classList.add('translate-x-full');
            });

            lucide.createIcons();

            const bellBtn = document.getElementById('notification-bell-btn');
            if (bellBtn) {
                bellBtn.addEventListener('click', () => {
                    const panel = document.getElementById('notification-panel');
                    if (!panel) return;
                    panel.classList.toggle('hidden');

                    // Optional: when panel opens, mark all visible notifications as read for this user
                    if (!panel.classList.contains('hidden')) {
                        // get all items currently displayed and mark them read
                        // (alternative: call a cloud function to mark read for admin role)
                        const listEl = document.getElementById('notification-list');
                        if (listEl && listEl.children.length > 0) {
                            Array.from(listEl.children).forEach(async (child, idx) => {
                                // We rely on snapshot listener to handle read state per-item when clicked.
                                // If you want 'mark all read' here, implement it with updateDoc on each doc.
                            });
                        }
                    }
                });
            }

            // "Clear All / Mark all read" button (client-side - marks each notification's readBy to include current user)
            const clearBtn = document.getElementById('clear-notifications-btn');
            if (clearBtn) {
                clearBtn.classList.remove('hidden'); // show it if permitted
                clearBtn.addEventListener('click', async () => {
                    if (!confirm('Delete all your notifications?')) return;

                    try {
                        const user = auth.currentUser;
                        if (!user) return;

                        const notificationsRef = collection(db, `artifacts/${sanitizedAppId}/users/${user.uid}/notifications`);
                        const snapshot = await getDocs(notificationsRef);

                        const deletions = snapshot.docs.map(d =>
                            deleteDoc(doc(db, `artifacts/${sanitizedAppId}/users/${user.uid}/notifications`, d.id))
                        );

                        await Promise.all(deletions);
                        showNotification('All notifications cleared.');
                    } catch (err) {
                        console.error('Failed to clear notifications:', err);
                        showNotification('Couldn\'t clear notifications. Check console.', 'error');
                    }
                });
            }



            // --- ALL AUTH LOGIC IS REMOVED FROM HERE ---
            // It now lives safely in the onAuthStateChanged listener
        });

        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('service-worker.js')
                    .then(registration => {
                        console.log('Service Worker registered with scope:', registration.scope);
                    })
                    .catch(error => {
                        console.error('Service Worker registration failed:', error);
                    });
            });
        }

    </script>
<script>
      // Listen on the main content area, which is more reliable
      const swipeTarget = document.getElementById('main-content');
      
      let touchStartX = 0;
      let touchEndX = 0;
      let swipeThreshold = 80; // Min pixels to trigger a swipe

      if (swipeTarget) {
        swipeTarget.addEventListener('touchstart', (e) => {
          // Only start swipe if it's from the far left edge of the screen
          if (e.changedTouches[0].screenX < 40) {
              touchStartX = e.changedTouches[0].screenX;
          } else {
              // Reset start if not from the edge, preventing accidental swipes
              touchStartX = 0; 
          }
        }, { passive: true });

        swipeTarget.addEventListener('touchend', (e) => {
          // Only trigger if touchStartX was set (i.e., started from the edge)
          if (touchStartX === 0) return;
            
          touchEndX = e.changedTouches[0].screenX;
          handleSwipe();
          touchStartX = 0; // Reset after swipe
        }, { passive: true });
      }

      function handleSwipe() {
        const diff = touchEndX - touchStartX;

        if (diff > swipeThreshold) {
          // Swipe right → open sidebars
          // We call the function defined in the previous script
          if(typeof openSidebars === 'function') {
            openSidebars();
          }
        } else if (diff < -swipeThreshold) {
          // Swipe left → close sidebars
          // We call the function defined in the previous script
          if(typeof closeSidebars === 'function') {
            closeSidebars();
          }
        }
      }

      // The overlay click is already handled by the new script
      // in Step 2, so we don't need it here.
    </script>

</body>

</html>